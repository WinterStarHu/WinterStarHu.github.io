<html>

<head>
    <meta charset="utf-8"/>
<meta name="description" content="Feel free to contact me."/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>小E教您学英语 | WinterStarHu Go语言</title>

<link rel="shortcut icon" href="https://WinterStarHu.github.io/favicon.ico?v=1688302623657">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://WinterStarHu.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">


<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>

<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-157397408-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());
        gtag('config', 'UA-157397408-1');
    </script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.0/mermaid.min.js"></script>
<script>
    var config = {
        startOnLoad:true,
        flowchart:{
            useMaxWidth:false,
            htmlLabels:true
        }
    };
    mermaid.initialize(config);
    $(function(){
        var elements = document.getElementsByClassName("language-mermaid");
        for (var i = elements.length; i--;) {
            element = elements[i];
            var graphDefinition = element.innerText;
            if (graphDefinition) {
                var svg = mermaid.render('ha_mermaid_' + i, graphDefinition, function(svg){});
                if (svg) {
                    var svgElement = document.createElement('div');
                    preNode = element.parentNode;
                    svgElement.innerHTML = svg;
                    svgElement.setAttribute('class', 'mermaid');
                    svgElement.setAttribute('data-processed', 'true');
                    preNode.parentNode.replaceChild(svgElement, preNode);
                }
            }
        }
    });
</script>
</head>

<body>
    <div class="main gt-bg-theme-color-first">
        <nav class="navbar navbar-expand-lg">
    <a href="/">
        <div class="navbar-brand">
            <img class="user-avatar" src="/images/avatar.png" alt="头像">
            <div class="site-name gt-c-content-color-first">
                WinterStarHu Go语言
            </div>
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav " style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1688302623657" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

        <div class="post-container">

            <!-- <div class="post-detail gt-bg-theme-color-second"> -->
            <article style="display:flex;">
                <div class="post-detail gt-bg-theme-color-second gt-post-content">
                    <h2 class="post-title">
                        小E教您学英语
                    </h2>
                    <div class="post-info">
                        <div>
                            <time class="post-time gt-c-content-color-first">
                                · 2020-03-01 ·
                            </time>
                            
                            <a href="https://WinterStarHu.github.io/tag/4rJPVvMAR/" class="post-tags">
                                # Python
                            </a>
                            
                            <a href="https://WinterStarHu.github.io/tag/3PWGpX0ngG/" class="post-tags">
                                # GitHub
                            </a>
                            
                        </div>
                        <div>
                            
                        </div>
                    </div>

                    <!-- <div class="post-content-wrapper"> -->
                    <div class="post-content">
                        
    <div class="toc-card i-card ">
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%AE%80%E4%BB%8B">软件简介</a></li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD">软件的功能</a></li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5">软件的输入</a>
<ul>
<li><a href="#%E8%AF%8D%E6%BA%90%E5%8D%95%E8%AF%8D%E8%A1%A8">词源单词表</a></li>
<li><a href="#%E6%99%AE%E9%80%9A%E5%8D%95%E8%AF%8D%E8%A1%A8">普通单词表</a></li>
<li><a href="#%E8%8B%B1%E8%AF%AD%E4%B9%A6%E7%B1%8D">英语书籍</a></li>
<li><a href="#%E8%8B%B1%E8%AF%AD%E5%AD%97%E5%B9%95ass">英语字幕ASS</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E8%AF%8D%E5%85%B8">用户词典</a></li>
<li><a href="#%E5%AD%A6%E8%BF%87%E7%9A%84%E5%8D%95%E8%AF%8D">学过的单词</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5xml">导入xml</a></li>
<li><a href="#%E9%9F%B3%E6%95%88">音效</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%BE%93%E5%87%BA">软件的输出</a>
<ul>
<li><a href="#%E5%8D%95%E8%AF%8D%E5%BE%97%E5%88%86%E8%A1%A8txt">单词得分表.txt</a></li>
<li><a href="#%E5%8D%95%E8%AF%8D%E6%84%8F%E6%80%9Dtxt">单词意思.txt</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B9%A6%E7%B1%8D">格式化书籍</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E5%B9%95">格式化字幕</a></li>
<li><a href="#%E8%AF%BB%E9%9F%B3">读音</a></li>
<li><a href="#%E5%AF%BC%E5%87%BAxml">导出xml</a>
<ul>
<li><a href="#%E5%AF%BC%E5%85%A5xml%E7%94%9F%E6%88%90%E7%9A%84txt">导入xml生成的txt</a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE">软件思维导图</a>
<ul>
<li><a href="#%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BA%93">软件使用的库</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AE%B9">软件程序的内容</a>
<ul>
<li><a href="#%E6%AF%8F%E4%B8%80%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E6%B3%95">每一部分实现的方法</a>
<ul>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0mainpy">主函数main.py</a></li>
<li><a href="#%E8%AF%8D%E6%BA%90%E7%B1%BBetymologypy">词源类etymology.py</a></li>
<li><a href="#%E5%8D%95%E8%AF%8D%E5%AD%A6%E4%B9%A0%E7%B1%BBword_learningpy">单词学习类word_learning.py</a></li>
</ul>
</li>
<li><a href="#%E5%8A%9F%E8%83%BD%E7%BB%86%E5%88%86">功能细分</a>
<ul>
<li><a href="#u"><u></a></li>
<li><a href="#u-2"><u></a></li>
<li><a href="#u-3"><u></a></li>
<li><a href="#u-4"><u></a>
<ul>
<li><a href="#u-5"><u></a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E5%B9%95">字幕</a></li>
<li><a href="#u-6"><u></a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#u-7"><u></a></li>
<li><a href="#lxml%E5%BA%93%E6%93%8D%E4%BD%9Cxml%E6%96%87%E4%BB%B6">lxml库操作xml文件</a>
<ul>
<li><a href="#u-8"><u></a></li>
<li><a href="#u-9"><u></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9">基本内容[^3]</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C">字符串操作</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E6%9D%A5%E4%BD%BF%E7%94%A8">函数作为参数来使用</a></li>
<li><a href="#u-10"><u></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8">日常使用</a></li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    

                        <p>已删除 词源法学英语 <a href="https://github.com/WinterStarHu/Little_E"><u>GitHub项目</u></a></p>
<p>历经02.29-03.08，终于完成了小E的编写，中间修改了无数的坑。当然这款软件包含很多的不足之处，作为python小白的我已经很尽力了。各位看官们，热闹笑话随你们看，只希望能给他人一点微薄的帮助。下面会介绍软件的功能，实现方式等。</p>
<!-- more -->
<h2 id="软件简介">软件简介</h2>
<p>​    	这是一种旨在使用词源学习法背单词的一种软件<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，视频教程可以参考<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<p>​		词源学习法的方式是通过一个词源扩展出不同的单词，例如form-&gt;conform-&gt;conformation。根据宋维钢老师的叙述，这种方式不同于市面上的联想记忆法，通过联想构造一个情形来背单词。这种方式不适用于多个单词，很有可能这种联想方式对于一个单词能够解释明白，另一个单词就矛盾了，而词源学习法是根据词源来学习的，英语中的<a href="%5Bhttps://github.com/WinterStarHu/Little_E/blob/master/res/res_xmind/%E5%B0%8FE.xmind%5D(https://github.com/WinterStarHu/Little_E/blob/master/res/res_xmind/%E5%B0%8FE.xmind)"><u>词源</u></a>是有依据的，所以不会矛盾。</p>
<h2 id="软件的功能">软件的功能</h2>
<figure data-type="image" tabindex="1"><img src="https://WinterStarHu.github.io/post-images/1583492034297.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>学习新单词</p>
<p>词源法学习新单词，每次学习首先要选择本次要学习的单词数<br>
<img src="https://WinterStarHu.github.io/post-images/1583492057295.png" alt="" loading="lazy"><br>
然后会随机选择一个词源，然后学习里面的单词，单词提供认识，不认识，划去，查看释义，重选单词功能。<br>
认识--&gt;得分50分。不认识--&gt;得分零分。划去--&gt;得分200分(不再学习)<br>
查看释义--&gt;查看释义  重选单词--&gt;重新选择单词<br>
<img src="https://WinterStarHu.github.io/post-images/1583492070775.png" alt="" loading="lazy"><br>
每个单词会包含音标、释义、词形、解析、词源、词源单词表上下级、例句等。</p>
<p>其中音标、释义来源于本地词典、金山、bing；词形来源于金山、enchant、textblob；解析来源于金山</p>
<p>词源、上下级来源于词源单词表；例句来源于本地、金山、书籍、字幕。</p>
<figure data-type="image" tabindex="2"><img src="https://WinterStarHu.github.io/post-images/1583492256572.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>从上次开始的地方继续背新词词源法</p>
<p>软件退出后会记录学习位置，下次进入可以继续从这个单词继续学习。</p>
</li>
<li>
<p>词源法单词考核<br>
拼写--&gt;得分80分<br>
<img src="https://WinterStarHu.github.io/post-images/1583492268898.png" alt="" loading="lazy"><br>
听写--&gt;得分90分<br>
<img src="https://WinterStarHu.github.io/post-images/1583492284069.png" alt="" loading="lazy"><br>
选择--&gt;得分100分<br>
<img src="https://WinterStarHu.github.io/post-images/1583492336803.png" alt="" loading="lazy"></p>
</li>
<li>
<p>温习词源法旧单词<br>
得分100分的单词可以再次学习，复用学习新单词的功能</p>
</li>
<li>
<p>单词表背词<br>
选择单词表<br>
<img src="https://WinterStarHu.github.io/post-images/1583492393254.png" alt="" loading="lazy"><br>
其他除了没有词源上下级之外，功能一样。</p>
</li>
<li>
<p>从上次开始的地方继续背新词-单词表</p>
</li>
<li>
<p>单词表单词考核</p>
</li>
<li>
<p>温习单词表旧单词</p>
</li>
<li>
<p>导出xml</p>
</li>
<li>
<p>导入xml</p>
</li>
<li>
<p>清空已学单词表<br>
清空词源法得分表和单词表得分表，不建议删除。不过误删有备份功能，备份本次删除的数据在./config/copy/当年-当月-当日_当时-当分-当秒/下，恢复数据仅需复制覆盖即可。</p>
</li>
</ol>
<h2 id="软件的输入">软件的输入</h2>
<h3 id="词源单词表">词源单词表</h3>
<p>​		路径：./res/res_md</p>
<p>​		由思维导图软件<a href="https://www.xmind.cn/"><u>xmind_zen</u></a>导出markdown文件作为软件的词源单词表，生成范例可以参考<a href="https://github.com/WinterStarHu/Little_E/tree/master/res/res_xmind"><u>res_xmind目录</u></a> [./res/res_xmind]下的文件。</p>
<h3 id="普通单词表">普通单词表</h3>
<p>​		路径：./res/res_word</p>
<p>​		由用户选择文本文件，读取后作为单词表。文本文件里的单词表格式为“英语单词+空格+其他” 软件仅读取空格前的英语单词。</p>
<h3 id="英语书籍">英语书籍</h3>
<p>​		路径：./res/res_book</p>
<p>​		大家都推荐学习英语单词时使用英语书籍里的句子作为单词例句。</p>
<h3 id="英语字幕ass">英语字幕ASS</h3>
<p>路径：./res/res_srt 仅支持.ass的文件</p>
<p>​		大家都推荐学习英语单词时使用英语字幕里的句子作为单词例句。</p>
<h3 id="用户词典">用户词典</h3>
<p>​		路径：./res/res_dict</p>
<p>​		英语单词的释义可以通过本地用户词典来获得。词典格式为：英语单词+空格+英语释义+【英语解析】</p>
<h3 id="学过的单词">学过的单词</h3>
<p>​		路径：./res/res_know</p>
<p>​		用户学过的单词可以写在一个txt里，然后这里的单词就不会再学习了</p>
<h3 id="导入xml">导入xml</h3>
<p>​		路径：自己给定 有道生成的xml文件 金山词霸的txt可以用有道转成xml然后再导入该软件</p>
<p>​		会导出单词表在./res/res_word和词典在./res/res_dict内</p>
<h3 id="音效">音效</h3>
<p>​		路径：./Sound_Effect</p>
<p>​		用在拼写单词或选择单词释义正确与否的时候播放音效。</p>
<h2 id="软件的输出">软件的输出</h2>
<h3 id="单词得分表txt">单词得分表.txt</h3>
<p>​		路径：./res/record</p>
<p>​		每个学习的单词都有得分，在得分变动后，关闭软件之前，会记录在单词得分表.txt里。</p>
<h3 id="单词意思txt">单词意思.txt</h3>
<p>​		路径：./res/record</p>
<p>​		每个英语单词的释义是可以存下来的。存下来以后可以可以在txt里更加舒服的看单词的意思，因为软件的GUI很简单，所以看着可能不舒服。</p>
<h3 id="格式化书籍">格式化书籍</h3>
<p>​	路径：./res/res_formatted_book</p>
<p>​	格式化后的书籍文件会存在这里</p>
<h3 id="格式化字幕">格式化字幕</h3>
<p>路径：./res/res_formatted_srt</p>
<p>格式化后的字幕文件会存在这里</p>
<h3 id="读音">读音</h3>
<p>​	路径：./Speech_EN和./Speech_US</p>
<p>​	每个学过的单词读音会存在这两个文件夹里</p>
<h3 id="导出xml">导出xml</h3>
<p>​	路径：./export</p>
<p>​	选择单词表导出xml文件供有道词典和金山词霸单词本使用</p>
<h4 id="导入xml生成的txt">导入xml生成的txt</h4>
<p>​	路径：./res/res_word和./res/res_dict</p>
<p>​	会导出单词表在./res/res_word和词典在./res/res_dict内</p>
<h3 id="配置文件">配置文件</h3>
<p>​		路径：./config</p>
<p>​		pkl后缀文件，由pickle来保存一些软件退出后该保存的配置。</p>
<ol>
<li>book.pkl用于存放已经处理过的书籍列表。由于书籍文件杂乱不齐，所以在起始时会进行处理，但是处理耗时，如果每次都处理会影响软件打开的时间，所以仅处理新增的文件。</li>
<li>cloud.pkl用于存放云端下载的文件，包括音标、释义、例句、解析、单词变形等等。</li>
<li>etmology_status.pkl 保存词源学习法每次退出前的单词位置。</li>
<li>word_tab_status.pkl 保存单词表学习法每次退出前的单词位置</li>
<li>word_mean.pkl 每一个存在单词意思.txt里的单词只能有一个，这是为了不重复保存相同的单词，便于保存</li>
<li>word_score.pkl 词源法单词得分 每一个词源法学过的单词都会存在这个里面</li>
<li>word_tab_score.pkl 单词表得分 每一个通过单词表学过的单词都会存在这个里面</li>
<li>srt.pkl 用于存放已经处理过的字幕列表。由于书籍文件杂乱不齐，所以在起始时会进行处理，但是处理耗时，如果每次都处理会影响软件打开的时间，所以仅处理新增的文件。</li>
</ol>
<h2 id="软件思维导图">软件思维导图</h2>
<p><a href="https://github.com/WinterStarHu/Little_E/blob/master/res/res_xmind/%E5%B0%8FE.xmind"><u>小E的思维导图</u></a>			<a href="%5Bhttps://github.com/WinterStarHu/Little_E/blob/master/res/res_xmind/%E5%B0%8FE.xmind%5D(https://github.com/WinterStarHu/Little_E/blob/master/res/res_xmind/%E5%B0%8FE.xmind)"><u>小E</u></a>的程序结构思维导图可以清晰的表示出该软件的实现流程。</p>
<h3 id="软件使用的库">软件使用的库</h3>
<p>内置库：time,sys,os,random</p>
<p>​				爬虫：urllib</p>
<p>外置库：GUI：<a href="https://blog.csdn.net/qiaoermeng/article/details/99718378"><u>easygui</u></a></p>
<p>​				文件存储：pickle</p>
<p>​				单词大小写、<a href="https://www.cnblogs.com/bonelee/p/7771609.html"><u>有效性检查</u></a>：textblob、enchant</p>
<p>​				执行bat,GUI：<a href="https://www.jb51.net/article/171293.htm"><u>pywin32</u></a></p>
<p>​				编码检测：<a href="https://www.cnblogs.com/schut/p/10579955.html"><u>chardet</u></a></p>
<p>​				爬虫：requests</p>
<p>​				xml文件：lxml</p>
<p>​				执行js代码：PyExecJs</p>
<p>​</p>
<p>​</p>
<h2 id="软件程序的内容">软件程序的内容</h2>
<h3 id="每一部分实现的方法">每一部分实现的方法</h3>
<h4 id="主函数mainpy">主函数main.py</h4>
<ol>
<li><a href="https://cloud.tencent.com/developer/ask/188486"><sub>控制是否打印</sub></a></li>
</ol>
<pre><code class="language-python"># Disable
def blockPrint():
    sys.stdout = open(os.devnull, 'w')

# Restore
def enablePrint():
    sys.stdout = sys.__stdout__
</code></pre>
<ol start="2">
<li>生成词源类对象</li>
</ol>
<p>利用读取文本文件的方式读取，通过观测词源文件的结构，可以发现词源为1个‘#’，其他的就是词源单词表，每个单词前面有#、-、空格，通过这个，就可以计算词源单词表中每个单词的数目。</p>
<pre><code class="language-python">def read_markdown(file_name):
    &quot;&quot;&quot;
    :param file_name: Xmin_ZEN生成的markdown文件
    :return: word_etymology:词源
             word_list:该词源对应的词源列表
             level_list:每一个单词在词源列表中代表的级数，
             			对应markdown内部的级数，表明单词与词源关系的大小
             word_num:该词源包含的单词数目
    &quot;&quot;&quot;
    level_list = []
    word_list = []
    # word_etymology = ' '
    # word_num = 0
    if os.path.exists(file_name):
        f = open(file_name, encoding='utf-8')  # 打开词源文件
        level_underline = 4  # 下划线的级别
        word_etymology = f.readline().strip('# ' + os.linesep)  # 第一行为词源
        for each in f:
            if '# ' in each:
                level_list.append(each.count('#'))
                word_list.append(each.strip('# ' + os.linesep))  # 去除换行符和空格
            elif '- ' in each:
                each = each.strip(os.linesep)  # 去除换行符
                each = each.split('- ')  # 以中划线和空格分割
                word_list.append(each[1])

                # 计算级别，中划线是4级，因为3个#之后才会出现中划线，中划线之后的级别以\t区份
                level_list.append(level_underline + each[0].count('\t'))
            else:
                pass
        f.close()
        word_num = len(word_list)
        assert word_num == len(level_list)  python# 如果不相等就会异常 false报异常
    else:
        return
    return word_etymology, word_list, level_list, word_num
</code></pre>
<h4 id="词源类etymologypy">词源类etymology.py</h4>
<p>可以更好的把词源单词表封装起来，每个词源对象对应一个词源文件。</p>
<h4 id="单词学习类word_learningpy">单词学习类word_learning.py</h4>
<ol>
<li>
<p>！！！不足：</p>
<ul>
<li>这个类过于复杂，把所有的功能几乎都封装再这个库里了，虽然使得主函数很简单，但是类的思想被破坏了。</li>
<li>初始化的东西太多了，这也是这个类复杂导致的</li>
<li>重复写的东西太多，有些东西本来可以分成多个部分，然后用上继承的思想，但是过于复杂，儿子继承了可能也很懵吧</li>
</ul>
</li>
<li>
<p>！！！改进：</p>
<ul>
<li>把各个功能模块拆分，最好封装成不同的类，比如把词源学习法和单词表学习法分开，然后基类是读写单词等等，子类从父类继承</li>
<li>主函数适当的扩充些内容，使类的东西稍微简单点，初始化的东西少一点</li>
</ul>
</li>
<li>
<p>主要函数：learn_word 400多行，分别介绍吧，实际上思想很简单，就是复写了好几遍导致代码比较多</p>
<ul>
<li>开始：功能选择：以下为框架代码：</li>
</ul>
</li>
</ol>
<pre><code class="language-python">learning_way = ['学习新单词', '词源法单词考核', '从上次开始的地方继续背新词--词源法', '温习词源法旧单词',
                    '单词表背词', '单词表单词考核', '从上次开始的地方继续背新词--单词表', '温习单词表旧单词']  # 学习方式 0 1 2 3 4 5 6 7
exit_status = '退出'  # 退出学习的标志
clear_status = '清空已学单词表'  # 清除选项
export_status = '导出xml'
way_choice = self.__way_form()
if way_choice is None:  # 不选就退出
    return self.word_num, self.left_word_num
if way_choice == self.export_status:  # 导出xml
if way_choice == self.clear_status:  # 清空单词表
if way_choice == self.learning_way[0] or way_choice == self.learning_way[2] or way_choice == self.learning_way[3]:
</code></pre>
<ul>
<li>
<p>不足：我为什么要把learning_way写成列表！！！！后面写各个功能实现的时候，我经常发疯，不知道自己到底在写哪个功能。。</p>
</li>
<li>
<p>这部分可以放在主函数里，这样功能就可以分多个文件来写了。</p>
</li>
<li>
<p>之所以有些功能放在一起，是因为大部分都是一样的，比如learning_way[0，2，3]他们的界面都是一样的，区别在于学习的单词不同，所以在实现他们的时候放在一起了。</p>
</li>
<li>
<p>学习单词数量选择</p>
<p>上面的功能选择也涉及到了GUI，这里选择的是<a href="https://blog.csdn.net/qiaoermeng/article/details/99718378"><u>easygui</u></a></p>
</li>
</ul>
<pre><code class="language-python">import easygui as gui
def __start_form(self):
    &quot;&quot;&quot;
    开始选择背单词单词数目
    :return:
    &quot;&quot;&quot;
    msg = '请输入要学习的单词数目(0~30)：'
    word_num = gui.integerbox(msg, self.title)  # 这一轮背单词数目
    if word_num is not None:
        if 30 &gt;= word_num &gt; 0:
            return int(word_num)  # 只允许最多背30个单词
        else:
            gui.msgbox(&quot;请不要输入小于0大于30的数字！&quot;, ok_button=&quot;OK&quot;)  # 提示单词小于30
            self.__start_form()  # 递归调用
    else:
        return None  # 返回退出标志
</code></pre>
<ul>
<li>功能：学习新单词，从上次开始的地方继续背新词--词源法，温习词源法旧单词</li>
<li><img src="https://WinterStarHu.github.io/post-images/1583492070775.png" alt="" loading="lazy">
<ul>
<li>
<p>这三个的窗口界面是一样的。词源法是指选择一个词源，然后本次的内容就背诵该词源单词表里的单词（由词源对象提供）</p>
</li>
<li>
<p>新单词不在单词得分表里，从上次开始的地方继续背新词--词源法是指软件需要记住退出后学习的单词列表及在单词列表中的位置。温习词源法旧单词是指单词在单词得分表里是100分。</p>
</li>
<li>
<p>当然，还需要考虑三种情况都需要考虑的内容：单词的位置不能超过列表长度，当位置移动到单词列表末尾就需要重新选择单词列表</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">def __choose_ety_start_pos(self, way_choice, score_high=0, score_low=0):
        # 2020.03.04选择从列表中选取一定数量的没背过的单词供这一轮使用，那么后面背单词过程出现错误的可能性就比较小
        ety = None
        start_pos = None
        word = None
        random.shuffle(self.etymology_list)  # 洗词源
        for each_ety in self.etymology_list:
            print('正在查找词源 %s' % each_ety.word_etymology)
            random.shuffle(each_ety.word_list)  # 洗词源里的列表
            for each_word_pos in range(len(each_ety.word_list)):
                each_word = each_ety.word_list[each_word_pos]
                if way_choice == self.learning_way[0] or way_choice == self.learning_way[
                    2] and each_word not in self.word_score_dict:
                    ety = each_ety
                    start_pos = each_word_pos
                    word = each_word
                    print('不在单词得分表中 已经找到词源：%s 在词源单词表中的位置：%d 起始单词：%s' % (ety.word_etymology, start_pos, word))
                    return ety, start_pos, word
                elif (way_choice == self.learning_way[1] or way_choice == self.learning_way[3]) \
                        and each_word in self.word_score_dict \
                        and score_low &lt;= self.word_score_dict[each_word] &lt;= score_high:  # 这里的or一定要加括号！
                    ety = each_ety
                    start_pos = each_word_pos
                    word = each_word
                    print('在单词得分表中 已经找到词源：%s 在词源单词表中的位置：%d 起始单词：%s 得分：%d'
                          % (ety.word_etymology, start_pos, word, self.word_score_dict[each_word]))
                    return ety, start_pos, word
                else:
                    pass
        print('未找到 均已经学完')
        return ety, start_pos, word
</code></pre>
<p>如上所示，选择单词的起始位置，是通过功能方式进行判断的，不同的条件能选出不同的单词，然后后面只需要选择列表中的元素即可。这部分比较考验逻辑能力，需要注意很多，比如筛选条件是不是会重合，矛盾？会不会出现列表越界？如果所有单词都学完了，是不是会无限循环查找？</p>
<ul>
<li>对于单词考核界面，主要包含单词选择，听写，拼写。单词选择是随机从单词表里选择单词，其中包含正确单词，然后翻译，得到界面。听写是播放单词的读音，然后用easygui的enterbox。拼写是显示单词的释义，也是用easygui的enterbox。</li>
</ul>
<h3 id="功能细分">功能细分</h3>
<p>考虑到泛泛的说会招人烦，所以我准备功能细分来说。这样我也能把细分的功能原理给研究研究。</p>
<h4 id="u"><a href="%5Bchardet%5D(https://www.cnblogs.com/schut/p/10579955.html)"><u>txt编码检测</u></a></h4>
<p>在读取用户给出的书籍或者字幕文件时，文件编码凌乱，如果只选择一种编码会造成异常，当然可以通过try except跳过这个文件，但是尽可能多的读取文件才是最好的，因此有了编码检测</p>
<pre><code class="language-python">def detectCode(self,file_path):
    with open(file_path, 'rb') as file:
        data = file.read(200000)
        dicts = chardet.detect(data)
        # print('编码：%s\n' %dicts[&quot;encoding&quot;])
        return dicts[&quot;encoding&quot;]
</code></pre>
<h4 id="u-2"><a href="https://www.cnblogs.com/bonelee/p/7771609.html"><u>单词有效性检查</u></a></h4>
<p>用户给出的单词不一定是正确的，所以需要进行单词有效性检测。</p>
<pre><code class="language-python">&gt;&gt;&gt; import enchant
&gt;&gt;&gt; d = enchant.Dict(&quot;en_US&quot;)
&gt;&gt;&gt; d.check(&quot;Hello&quot;)
True
&gt;&gt;&gt; d.check(&quot;Helo&quot;)
False
&gt;&gt;&gt; d.suggest(&quot;Helo&quot;)
['He lo', 'He-lo', 'Hello', 'Helot', 'Help', 'Halo', 'Hell', 'Held', 'Helm', 'Hero', &quot;He'll&quot;]
&gt;&gt;&gt;
</code></pre>
<h4 id="u-3"><a href="https://textblob.readthedocs.io/en/latest/quickstart.html#quickstart"><u>单词单复数 动词原形</u></a></h4>
<p>TextBlob 只是这个功能也很蠢，因为名词也有可数和不可数。。但是这里并不区分。不过用来作为查词容错的工具是不错的，如果要查的单词查不到，那么单数，复数，动词原形以及enchant的suggest列表里的是不是有呢？</p>
<pre><code class="language-python">&gt;&gt;&gt; sentence = TextBlob('Use 4 spaces per indentation level.')
&gt;&gt;&gt; sentence.words
WordList(['Use', '4', 'spaces', 'per', 'indentation', 'level'])
&gt;&gt;&gt; sentence.words[2].singularize()
'space'
&gt;&gt;&gt; sentence.words[-1].pluralize()
'levels'
</code></pre>
<h4 id="u-4"><a href="https://www.cnblogs.com/gl1573/p/10129382.html"><u>request模块</u></a></h4>
<p>所以我优先会选用金山的翻译，金山的API很好用，例句，词典，单词单复数等等应有尽有。</p>
<pre><code class="language-python">def get_synword_exchange(string):
    print('金山同义词查询 %s' % string)
    time.sleep(0.02)
    data = ''
    # 请求API
    url = 'http://www.iciba.com/index.php?a=getWordMean&amp;c=search&amp;word=' + string
    try:
        req = requests.get(url, timeout=2)
        # 处理返回的JSON数据
        info = req.json()
        if 'baesInfo' in info:
            if 'exchange' in info['baesInfo']:
                print('exchange')
                if 'word_pl' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_pl']) &gt; 0:
                    data += '复数：' + info['baesInfo']['exchange']['word_pl'][0] + ' '
                if 'word_third' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_third']) &gt; 0:
                    data += '第三人称：' + info['baesInfo']['exchange']['word_third'][0] + ' '
                if 'word_past' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_past']) &gt; 0:
                    data += '过去式：' + info['baesInfo']['exchange']['word_past'][0] + ' '
                if 'word_done' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_done']) &gt; 0:
                    data += '被动式：' + info['baesInfo']['exchange']['word_done'][0] + ' '
                if 'word_ing' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_ing']) &gt; 0:
                    data += '被动式：' + info['baesInfo']['exchange']['word_ing'][0] + ' '
                if 'word_adv' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_adv']) &gt; 0:
                    data += '副词：' + info['baesInfo']['exchange']['word_adv'][0] + ' '
                if 'word_verb' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_verb']) &gt; 0:
                    data += '动词：' + info['baesInfo']['exchange']['word_verb'][0] + ' '
                if 'word_noun' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_noun']) &gt; 0:
                    data += '名词：' + info['baesInfo']['exchange']['word_noun'][0] + ' '
                if 'word_adj' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_adj']) &gt; 0:
                    data += '形容词：' + info['baesInfo']['exchange']['word_adj'][0] + ' '
                if 'word_prep' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_prep']) &gt; 0:
                    data += '介词：' + info['baesInfo']['exchange']['word_prep'][0] + ' '
                if 'word_er' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_er']) &gt; 0:
                    data += '比较级：' + info['baesInfo']['exchange']['word_er'][0] + ' '
                if 'word_est' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_est']) &gt; 0:
                    data += '最高级：' + info['baesInfo']['exchange']['word_est'][0] + ' '
                if 'word_conn' in info['baesInfo']['exchange'] and len(info['baesInfo']['exchange']['word_conn']) &gt; 0:
                    data += '最高级：' + info['baesInfo']['exchange']['word_conn'][0] + ' '
            if len(data) &gt; 1:
                data += '\n'
        if 'synonym' in info:
            print('synonym')
            for each in info['synonym']:
                if 'part_name' in each:
                    data += each['part_name']
                if 'means' in each:
                    for each_mean in each['means']:
                        data += each_mean['word_mean'] + ':' + str(each_mean['cis']) + '\n'
        if 'sameAnalysis' in info:
            print('sameAnalysis')
            for each in info['sameAnalysis']:
                if 'part_name' in each:
                    data += each['part_name']+'\n'
                if 'means' in each:
                    for each_mean in each['means']:
                        data += each_mean + '\n'
            if len(data) &gt; 1:
                data += '\n'
        if 'exchanges' in info:
            for each in info['exchanges']:
                if each not in info['exchanges']:
                    data += each + ' '
            if len(data) &gt; 1:
                data += '\n'
    except Exception as ex:
        print('出现异常 %s' % ex)
        data = None
    # print('数据长度：%d' % len(data))
    if data and len(data) &lt;= 1:
        print('数据长度：%d' % len(data))
        print('舍弃为1的data')
        data = None
    return data
</code></pre>
<p>当然上述功能，TextBlob也有提供，当然依旧不好用</p>
<pre><code class="language-python">&gt;&gt;&gt; from textblob import Word
&gt;&gt;&gt; from textblob.wordnet import VERB
&gt;&gt;&gt; word = Word(&quot;octopus&quot;)
&gt;&gt;&gt; word.synsets
[Synset('octopus.n.01'), Synset('octopus.n.02')]
&gt;&gt;&gt; Word(&quot;hack&quot;).get_synsets(pos=VERB)
[Synset('chop.v.05'), Synset('hack.v.02'), Synset('hack.v.03'), Synset('hack.v.04'), Synset('hack.v.05'), Synset('hack.v.06'), Synset('hack.v.07'), Synset('hack.v.08')]
</code></pre>
<p><a href="https://blog.csdn.net/sunt2018/article/details/92788185"><u>request模块设置超时</u></a>主要是用来设置超时时间，防止程序卡在request过久</p>
<p>API存在失效的情况，我尝试过很多API，发现很多都失效了，比如百度的，<a href="https://blog.csdn.net/qq_31998745/article/details/80663786"><u>bing</u></a>的等等</p>
<h5 id="u-5"><a href="https://blog.csdn.net/waterforest_pang/article/details/16885259"><u>url.open</u></a> 这个应该是爬虫工具了，我找到一个bing的爬虫，可以使用，就是速度很慢</h5>
<h4 id="字幕">字幕</h4>
<p>推荐<a href="http://www.zimuku.la/"><u>下载字幕网站</u></a></p>
<p>由于下载的字幕是ASS文件所以我使用<a href="https://mathpretty.com/10393.html"><u>asstosrt</u></a> <a href="https://github.com/sorz/asstosrt"><u>GitHub网址</u></a>，支持import。</p>
<pre><code class="language-python">import asstosrt

ass_file = open('example.ass')
srt_str = asstosrt.convert(ass_file)
</code></pre>
<p>然后使用库<a href="https://github.com/cdown/srt"><u>srt</u></a></p>
<pre><code class="language-python">&gt;&gt;&gt; # list() is needed as srt.parse creates a generator
&gt;&gt;&gt; subs = list(srt.parse('''\
... 1
... 00:00:33,843 --&gt; 00:00:38,097
... 地球上只有3%的水是淡水
...
... 2
... 00:00:40,641 --&gt; 00:00:44,687
... 可是这些珍贵的淡水中却充满了惊奇
...
... 3
... 00:00:57,908 --&gt; 00:01:03,414
... 所有陆地生命归根结底都依赖於淡水
...
... '''))
&gt;&gt;&gt; subs
[Subtitle(index=1, start=datetime.timedelta(0, 33, 843000), end=datetime.timedelta(0, 38, 97000), content='地球上只有3%的水是淡水', proprietary=''),
 Subtitle(index=2, start=datetime.timedelta(0, 40, 641000), end=datetime.timedelta(0, 44, 687000), content='可是这些珍贵的淡水中却充满了惊奇', proprietary=''),
 Subtitle(index=3, start=datetime.timedelta(0, 57, 908000), end=datetime.timedelta(0, 63, 414000), content='所有陆地生命归根结底都依赖於淡水', proprietary='')]
&gt;&gt;&gt; print(srt.compose(subs))
1
00:00:33,843 --&gt; 00:00:38,097
地球上只有3%的水是淡水

2
00:00:40,641 --&gt; 00:00:44,687
可是这些珍贵的淡水中却充满了惊奇

3
00:00:57,908 --&gt; 00:01:03,414
所有陆地生命归根结底都依赖於淡水
</code></pre>
<p>另外还有库<a href="https://github.com/byroot/pysrt"><u>pysrt</u></a>，<a href="https://www.kutu66.com//GitHub/article_137708"><u>pysrt的解释</u></a>我没有尝试过。</p>
<h4 id="u-6"><a href="https://www.cnblogs.com/heenhui2016/p/10805525.html"><u>文件夹操作</u></a></h4>
<p>对于文件夹下的文件，以及文件夹下的子文件夹等等一系列问题，我只涉及到了文件夹下的文件和文件夹下的子文件夹。</p>
<ul>
<li><a href="https://www.cnblogs.com/charlesblc/p/7070516.html"><u>创建文件夹</u></a></li>
<li><a href="https://www.cnblogs.com/xianyulouie/p/11041772.html"><u>文件后缀名</u></a></li>
<li><a href="https://blog.csdn.net/s740556472/article/details/80574631"><u>遍历多层文件夹</u></a></li>
<li>路径的提取，os.path.split os.path.splittext等等</li>
<li>绝对路径 os.path.realpath</li>
<li>列举文件夹和文件夹下的文件 os.listdir 举个例子，一看便知</li>
</ul>
<pre><code class="language-python">def __read(self):
    # 遍历文件夹
    # 遍历根目录

    formatted_flag = False
    for dir in os.listdir(self.user_srt_dir):
        for file in os.listdir(self.user_srt_dir + dir):
            if file not in self.formatted_srt:
                formatted_flag = True
    if formatted_flag:
        win32api.ShellExecute(win32con.NULL, 'open', self.sound_effect_wait, '', '', win32con.SW_HIDE)

        for dir in os.listdir(self.user_srt_dir):
            format_srt_dir = os.path.join(self.user_formatted_srt_dir, dir)
            if not os.path.exists(format_srt_dir):  # 不存在格式化的目录就创建一个
                os.makedirs(format_srt_dir)
            for file in os.listdir(self.user_srt_dir + dir):
                if file not in self.formatted_srt:
                    self.formatted_srt.append(file)
                    file_name = os.path.join(self.user_srt_dir, dir, file)
                    print(file_name)
                    # subs = pysrt.open(file_name, encoding='iso-8859-1')
                    # print(len(subs))
                    if file_name.endswith(&quot;.ass&quot;):
                        # format_file = os.path.splitext(file)[0] + '.txt'
                        format_file = file+'.txt'  # 这样可以获得原始文件的后缀名
                        format_file_name = os.path.join(format_srt_dir, format_file)
                        print(format_file_name)
                        ass_file = open(file_name, encoding=self.detectCode(file_name))
                        srt_str = asstosrt.convert(ass_file)
                        subtitle_generator = srt.parse(srt_str)
                        subtitles = list(subtitle_generator)
                        # print(len(subtitles))
                        # print(subtitles[1].content)
                        with open(format_file_name, 'w', encoding='utf-8') as f:
                            for each in subtitles:
                                f.write(each.content.replace('\n',' ')+'\n')
    return formatted_flag
</code></pre>
<h4 id="缓存">缓存</h4>
<p>一个单词查完音标、释义、例句、解析等等总要耗费一点时间，为了快速的再次读取，需要使用pickle来存放已经查完的单词。</p>
<pre><code class="language-python">    def __read_pkl(self):
        with open(self.srt_status_pkl, 'rb') as pickle_file:
            self.formatted_srt = pik.load(pickle_file)  # 读取配置文件

    def __save_pkl(self):
        srt_status_dir = os.path.split(self.srt_status_pkl)[0]
        if not os.path.exists(srt_status_dir):
            os.makedirs(srt_status_dir)
        with open(self.srt_status_pkl, 'wb') as pickle_file:
            pik.dump(self.formatted_srt, pickle_file)
</code></pre>
<h4 id="u-7"><a href="https://www.cnblogs.com/xiaohe520/p/10973307.html"><u>WIN32.API</u></a></h4>
<p>弹窗</p>
<pre><code class="language-python"># 按钮示例
import win32api
import win32con
win32api.MessageBox(None,&quot;Hello,pywin32!&quot;,&quot;pywin32&quot;,win32con.MB_OK)
</code></pre>
<p>模拟按键，我利用这个实现了记事本打开，然后查找某个单词</p>
<pre><code class="language-python">
def text_find(txt_path,str):
    &quot;&quot;&quot;
    :param txt_path: txt文件路径
    :param str: 查找的字符串
    :return:None
    &quot;&quot;&quot;
    txt_path = os.path.realpath(txt_path)
    # win32api.ShellExecute(0, 'open', txt_exe,txt_path , '', 1)  # 打开txt
    win32api.ShellExecute(0, 'open', txt_path, '', '',1)  # 打开txt
    time.sleep(0.8) # 打开记事本需要时间！！！ 不然后面找不到窗口！！
    _,txt_name = os.path.split(txt_path)

    windows_title = get_windows_title(txt_name)
    print('要打开的窗口标题 %s\n' %windows_title)
    if windows_title:
        show(windows_title)

        time.sleep(0.02)
        # 按下组合键 ctrl + f
        press_key('ctrl', 'f')

        # 切换中英文
        press_key('shift')
        time.sleep(0.02)  # 英文切换时间
        str=str[0: min(15,len(str))]  # 只搜索前10个字符
        try:
            key_input_str(str)
        except Exception as ex:
            print('某些字符不知道怎么打印 错误类型:%s' %ex)

        time.sleep(0.02)  # 搜索需要时间

        # 按下enter
        press_key('enter')
    else:
        print('未找到该文件窗口')
</code></pre>
<p>win32api还可以打开音乐等等</p>
<pre><code class="language-python">win32api.ShellExecute(win32con.NULL, 'open', filename, '', '', win32con.SW_HIDE)
</code></pre>
<p>我这里的读英语单词就是使用这个办法，<a href="https://www.cnblogs.com/ocean1100/p/9319891.html"><u>pygame播放音乐</u></a>太占用时间了</p>
<h4 id="lxml库操作xml文件">lxml库操作xml文件</h4>
<h5 id="u-8"><a href="https://blog.csdn.net/pursuit_zhangyu/article/details/79902626"><u>xml生成</u></a></h5>
<pre><code class="language-python">    def word_xml(self, root, word, file):
        &quot;&quot;&quot;

        :param root: 父节点
        :param word: 单词
        :param file: 单词来自的文件
        :return:
        &quot;&quot;&quot;
        # 创建一个子节点item，一定要指定父节点
        child1 = etree.SubElement(root, 'item')
        child1_child1 = etree.SubElement(child1, 'word')
        child1_child1.text = word
        child1_child2 = etree.SubElement(child1, 'trans')
        time.sleep(0.2)
        child1_child2.text = self.__intelligent_mean(word)
        # child1_child3 = etree.SubElement(child1,'phonetic')
        # time.sleep(0.2)
        # child1_child3.text = self.__intelligent_yingbiao(word)
        child1_child4 = etree.SubElement(child1, 'tags')
        child1_child4.text = os.path.splitext(os.path.split(file)[1])[0]
        child1_child5 = etree.SubElement(child1, 'progress')
        child1_child5.text = '1'
</code></pre>
<h5 id="u-9"><a href="https://blog.csdn.net/weixin_42333583/article/details/100893388"><u>xml解析</u></a></h5>
<pre><code class="language-python">tree = etree.parse(file)  # 获取树结构
            root = tree.getroot()  # 获取根节点
            word_tab_dir = os.path.split(self.word_tab_default_path)[0]
            dict_dir = self.user_dict_dir
            word = ''
            yingbiao = ''
            mean = ''
            for elements in root:
                for element in elements:  # 获取第三层标签
                    # print(element.tag,':',element.text) #.tag获取节点（标签）名称，.text获取两个标签中间夹着的内容
                    # if element.tag == 'tags':
                    #     tags=element.text
                    if element.tag == 'word':
                        word = element.text
                    if element.tag == 'phonetic':
                        yingbiao = element.text
                    if element.tag == 'trans':
                        mean = element.text
                    if element.tag == 'tags':
                        filename = element.text + time.strftime(&quot; %Y-%m-%d-%H-%M&quot;, time.localtime()) + '.txt'
</code></pre>
<h3 id="基本内容">基本内容<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h3>
<h4 id="字符串操作">字符串操作</h4>
<p>例如split,replace</p>
<h4 id="变量">变量</h4>
<p>列表、元组、类、魔法方法</p>
<h4 id="函数">函数</h4>
<p><a href="https://blog.csdn.net/xylin1012/article/details/81236122"><u>args的使用</u></a></p>
<h4 id="函数作为参数来使用">函数作为参数来使用</h4>
<p>这一点我感觉是我最引以为傲的使用了，我想在各种窗口下面都使用发音函数，那么我在调用各种窗口的时候，调用发音函数，然后把窗口函数以参数方式传入，这样不同模块都可以共用。</p>
<pre><code class="language-python">    def __speak_sound(self, word, speak_types, func, *argc):
        # pygame.mixer.init()

        filename = self.sp.speak_file(word, speak_types[0])
        # audio = MP3(filename)
        print(&quot;播放音乐1&quot;)
        # pygame.mixer.music.load(filename)
        # pygame.mixer.music.play()

        win32api.ShellExecute(win32con.NULL, 'open', filename, '', '', win32con.SW_HIDE)

        # 不能做到播放两个音乐
        if len(speak_types) &gt; 1:
            filename = self.sp.speak_file(word, speak_types[1])
            if len(argc) &gt;= 4:
                res = func(argc[0], argc[1], argc[2], argc[3], filename)
            elif len(argc) == 3:
                res = func(argc[0], argc[1], argc[2], filename)
            elif len(argc) == 2:
                res = func(argc[0], argc[1], filename)
            elif len(argc) == 1:  # 暂时只使用这个了 用于释义窗口 mean form
                res = func(argc[0], filename)
            else:
                res = func(self, filename)
        else:
            # 调用form会使程序暂停，不能继续向前走，所以不能重复播放两次，但是如果提前播放音乐看不见窗口
            if len(argc) &gt;= 4:
                res = func(argc[0], argc[1], argc[2], argc[3])
            elif len(argc) == 3:
                res = func(argc[0], argc[1], argc[2])
            elif len(argc) == 2:
                res = func(argc[0], argc[1])
            elif len(argc) == 1:
                res = func(argc[0])
            else:
                res = func(self)

        # pygame.time.delay(int(audio.info.length))  # 等待单词时间让mp3播放结束
        # pygame.mixer.music.stop()

        return res
</code></pre>
<p>调用：</p>
<pre><code class="language-python">result = self.__speak_sound(self.word, ['us', 'en'], self.__mean_form, self.word)
</code></pre>
<h4 id="u-10"><a href="https://blog.csdn.net/jlulxg/article/details/84650683"><u>正则表达式</u></a></h4>
<p>使用库re</p>
<pre><code>#过滤@和数字
yingbiao = '[' + re.sub(r'[ˈ0-9@]', &quot;&quot;, yingbiao) + ']'
</code></pre>
<h2 id="日常使用">日常使用</h2>
<p>第一次想法就是打包成exe，尝试过<a href="https://zhuanlan.zhihu.com/p/76974787"><u>pyinstaller</u></a>并没有成功，可能是我错过了很多关键的东西。<br>
翻翻<a href="https://www.zhihu.com/question/281858271"><u>知乎的回答</u></a>，偶然间看见了<a href="https://zhuanlan.zhihu.com/p/77028265"><u>嵌入式python</u></a>，既然这样，那么我就直接使用anaconda下我所使用环境的exe，直接写一个bat，就可以打开了，然后再加个图标，挺省事的，也不用打开编辑器了。</p>
<pre><code>C:\yingyong\anaconda3\envs\Little_E_lib\python.exe C:\Users\Administrator\PycharmProjects\Little_E\main.py·
</code></pre>
<p>在编写过程中使用了各个博主的代码加以整合，最终形成了这个软件，感谢各位造轮子的人！！感谢您的观看！！</p>
<p>参考文献：</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>钱磊. 英语词源故事集锦[M]. 北京航空航天大学出版社, 2018. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>【跟谁学】宋维钢 词霸天下38000词 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>小甲鱼. 零基础入门学习Python[M]. 清华大学出版社, 2016. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
 
                    </div>
                    <div class="essaySuffix-box">
                        <div class="essaySuffix-box-left"><img
                                src="/images/avatar.png" alt="">
                        </div>
                        <div class="essaySuffix-box-right"><span
                                class="essaySuffix-right-title">本文作者</span>：<strong><span style="font-size: 12px;"><a
                                        href="/about"
                                        target="_blank">WinterStarHu Go语言</a></span></strong> <br><span
                                style="font-weight: bold; white-space:nowrap;">本文链接</span>：<a
                                href="https://WinterStarHu.github.io/post/xiao-e-jiao-nin-xue-ying-yu/"
                                target="_blank">https://WinterStarHu.github.io/post/xiao-e-jiao-nin-xue-ying-yu/</a><br><span
                                class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a
                                href="https://creativecommons.org/licenses/by-nc-nd/4.0/" alt="BY-NC-SA"
                                title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</div>
                        <div style="clear: both;"></div>
                    </div>
                </div>
                <!-- </div> -->
                <div class="toc-container">
                    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%AE%80%E4%BB%8B">软件简介</a></li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD">软件的功能</a></li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5">软件的输入</a>
<ul>
<li><a href="#%E8%AF%8D%E6%BA%90%E5%8D%95%E8%AF%8D%E8%A1%A8">词源单词表</a></li>
<li><a href="#%E6%99%AE%E9%80%9A%E5%8D%95%E8%AF%8D%E8%A1%A8">普通单词表</a></li>
<li><a href="#%E8%8B%B1%E8%AF%AD%E4%B9%A6%E7%B1%8D">英语书籍</a></li>
<li><a href="#%E8%8B%B1%E8%AF%AD%E5%AD%97%E5%B9%95ass">英语字幕ASS</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E8%AF%8D%E5%85%B8">用户词典</a></li>
<li><a href="#%E5%AD%A6%E8%BF%87%E7%9A%84%E5%8D%95%E8%AF%8D">学过的单词</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5xml">导入xml</a></li>
<li><a href="#%E9%9F%B3%E6%95%88">音效</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%BE%93%E5%87%BA">软件的输出</a>
<ul>
<li><a href="#%E5%8D%95%E8%AF%8D%E5%BE%97%E5%88%86%E8%A1%A8txt">单词得分表.txt</a></li>
<li><a href="#%E5%8D%95%E8%AF%8D%E6%84%8F%E6%80%9Dtxt">单词意思.txt</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B9%A6%E7%B1%8D">格式化书籍</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E5%B9%95">格式化字幕</a></li>
<li><a href="#%E8%AF%BB%E9%9F%B3">读音</a></li>
<li><a href="#%E5%AF%BC%E5%87%BAxml">导出xml</a>
<ul>
<li><a href="#%E5%AF%BC%E5%85%A5xml%E7%94%9F%E6%88%90%E7%9A%84txt">导入xml生成的txt</a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE">软件思维导图</a>
<ul>
<li><a href="#%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BA%93">软件使用的库</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AE%B9">软件程序的内容</a>
<ul>
<li><a href="#%E6%AF%8F%E4%B8%80%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E6%B3%95">每一部分实现的方法</a>
<ul>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0mainpy">主函数main.py</a></li>
<li><a href="#%E8%AF%8D%E6%BA%90%E7%B1%BBetymologypy">词源类etymology.py</a></li>
<li><a href="#%E5%8D%95%E8%AF%8D%E5%AD%A6%E4%B9%A0%E7%B1%BBword_learningpy">单词学习类word_learning.py</a></li>
</ul>
</li>
<li><a href="#%E5%8A%9F%E8%83%BD%E7%BB%86%E5%88%86">功能细分</a>
<ul>
<li><a href="#u"><u></a></li>
<li><a href="#u-2"><u></a></li>
<li><a href="#u-3"><u></a></li>
<li><a href="#u-4"><u></a>
<ul>
<li><a href="#u-5"><u></a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E5%B9%95">字幕</a></li>
<li><a href="#u-6"><u></a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#u-7"><u></a></li>
<li><a href="#lxml%E5%BA%93%E6%93%8D%E4%BD%9Cxml%E6%96%87%E4%BB%B6">lxml库操作xml文件</a>
<ul>
<li><a href="#u-8"><u></a></li>
<li><a href="#u-9"><u></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9">基本内容[^3]</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C">字符串操作</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E6%9D%A5%E4%BD%BF%E7%94%A8">函数作为参数来使用</a></li>
<li><a href="#u-10"><u></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8">日常使用</a></li>
</ul>
</li>
</ul>

                </div>
            </article>
            <!-- </div> -->

          

            

            
            
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'f8e90542c37bcacd90e3',
    clientSecret: '05654d01e307789fa9cd6ab3f438205d12a040f0',
    repo: 'winterstarhu.github.io',
    owner: 'WinterStarHu',
    admin: ['WinterStarHu'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
            

            

            <div class="site-footer gt-c-content-color-first">

  <div class="social-container">

    <a href="https://github.com/WinterStarHu" target="_blank" title="https://github.com/WinterStarHu">
      <i class="fab fa-github gt-c-content-color-first"></i>
    </a>

    <a href="https://home.cnblogs.com/u/1859312/" target="_blank" title="https://home.cnblogs.com/u/1859312/">
      <i class="fas fa-blog gt-c-content-color-first"></i>
    </a>

    <a href="https://blog.csdn.net/qq_33705315" target="_blank" title="https://blog.csdn.net/qq_33705315">
      <i class="fab fa-cuttlefish gt-c-content-color-first"></i>
    </a>

    <a href="mailto:dongxinghu@foxmail.com" title="dongxinghu@foxmail.com">
      <i class="fas fa-envelope gt-c-content-color-first"></i>
    </a>

  </div>
  <div class="slogan gt-c-content-color-first">Feel free to contact me.</div>
  
  <div class="footer-info">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  </div>
  
  <div>
    <div>
      Theme by <a href="https://github.com/WinterStarHu/gridea-theme-pure-fashion-new" target="_blank">winterstarhu</a>, Powered by <a
              href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://WinterStarHu.github.io/atom.xml" target="_blank">RSS</a></a>
  </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

            <script>
  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");
  
  if (mainNavLinks == null || mainNavLinks.length == 0) {
    let tocContainer = document.querySelector(".toc-container");
    tocContainer.classList.remove("toc-container")
    // tocContainer.parentElement.firstElementChild.style.width = "100%"
    console.log("隐藏大纲")
  } else {

    // This should probably be throttled.
    // Especially because it triggers during smooth scrolling.
    // https://lodash.com/docs/4.17.10#throttle
    // You could do like...
    // window.addEventListener("scroll", () => {
    //    _.throttle(doThatStuff, 100);
    // });
    // Only not doing it here to keep this Pen dependency-free.


    window.addEventListener("scroll", event => {
      let fromTop = window.scrollY;

      mainNavLinks.forEach((link, index) => {
        let section = document.getElementById(decodeURI(link.hash).substring(1));
        let nextSection = null
        if (mainNavLinks[index + 1]) {
          nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
        }
        if (section.offsetTop <= fromTop) {
          if (nextSection) {
            if (nextSection.offsetTop > fromTop) {
              link.classList.add("current");
            } else {
              link.classList.remove("current");
            }
          } else {
            link.classList.add("current");
          }
        } else {
          link.classList.remove("current");
        }
      });
    });
  }



</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll("figure > img");
  //   debugger
  //   console.log("dddd: "+ images);
  images.forEach(image => {
    var parent = image.parentElement;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'gallery';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.appendChild(aelem);
  })

//   <a data-fancybox="gallery" href="big_1.jpg"><img src="small_1.jpg"></a>
// <a data-fancybox="gallery" href="big_2.jpg"><img src="small_2.jpg"></a>
</script>
        </div>
    </div>

</body>

</html>
