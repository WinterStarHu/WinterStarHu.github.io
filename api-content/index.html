{"posts":[{"title":"Version","content":"1.0 ","link":"https://WinterStarHu.github.io/post/version/"},{"title":"NoteExpress高校版很好用！","content":"http://www.inoteexpress.com/download_chs.htm#Tutorials 任意选择一个高校版即可使用！ Ref：https://baijiahao.baidu.com/s?id=1575884148799639 ","link":"https://WinterStarHu.github.io/post/noteexpress-gao-xiao-ban-hen-hao-yong/"},{"title":"网址推荐","content":" 可以下载英文电子书的网站：https://vdoc.pub/，之前下过很多技术书籍 http://www.9871.org/ 综合搜索书籍 ","link":"https://WinterStarHu.github.io/post/wang-zhi-tui-jian/"},{"title":"使用vscode代替typora","content":"typora开始收费了，虽然很好用，但是望尘莫及，还是继续使用vscode吧。 图床 首先解决图片链接的问题，之前在typora也没使用过这个功能，这一次在vscode解决。 方法如下： 使用OneDrive做图床 分享链转换为直链 如下是使用Onedrive后转换为直链的结果： vscode插件 vscode使用markdown指导 再见Typora！5分钟从Typora迁移到VScode！ Markdown All in One Markdown Shortcuts Auto Markdown 思维导图 GitMind免费使用 ","link":"https://WinterStarHu.github.io/post/shi-yong-vscode-dai-ti-typora/"},{"title":"Go Slice，Map，Struct排坑","content":"收集帖 本帖主要收集关于Slice，Map，Struct遇到的坑，不定时更新，总结 Slice Slice底层是一个数组，在进行Slice赋值操作时，底层的数组是不改变的，只是Slice的可见长度改变了，容量也是会不变的。Slice的数据结构是包含指针，长度，容量三个值的结构体。 package main import &quot;fmt&quot; func changeSlice(arr []int){ fmt.Printf(&quot;changeSlice中传入的arr %p %v 长度：%d 容量%d\\n&quot;,&amp;arr,arr,len(arr),cap(arr)) arr[0]++ fmt.Printf(&quot;changeSlice中传入的arr change后 %p %v 长度：%d 容量%d\\n&quot;,&amp;arr,arr,len(arr),cap(arr)) arr=append(arr,0) fmt.Printf(&quot;changeSlice中传入的arr add后 %p %v 长度：%d 容量%d\\n&quot;,&amp;arr,arr,len(arr),cap(arr)) } func main(){ arr1:=[]int{1,2,3} arr2:=arr1 fmt.Printf(&quot;main的arr1 %p %v 长度：%d 容量%d \\n&quot;,&amp;arr1,arr1,len(arr1),cap(arr1)) changeSlice(arr1) fmt.Printf(&quot;main的arr1 change后 %p %v 长度：%d 容量%d \\n&quot;,&amp;arr1,arr1,len(arr1),cap(arr1)) fmt.Printf(&quot;main的arr2 %p %v 长度：%d 容量%d\\n&quot;,&amp;arr2,arr2,len(arr2),cap(arr2)) changeSlice(arr2) fmt.Printf(&quot;main的arr2 change后 %p %v 长度：%d 容量%d\\n&quot;,&amp;arr2,arr2,len(arr2),cap(arr2)) } 输出 main的arr1 0xc000004078 [1 2 3] 长度：3 容量3 changeSlice中传入的arr 0xc0000040c0 [1 2 3] 长度：3 容量3 changeSlice中传入的arr change后 0xc0000040c0 [2 2 3] 长度：3 容量3 changeSlice中传入的arr add后 0xc0000040c0 [2 2 3 0] 长度：4 容量6 main的arr1 change后 0xc000004078 [2 2 3] 长度：3 容量3 main的arr2 0xc000004090 [2 2 3] 长度：3 容量3 changeSlice中传入的arr 0xc000004150 [2 2 3] 长度：3 容量3 changeSlice中传入的arr change后 0xc000004150 [3 2 3] 长度：3 容量3 changeSlice中传入的arr add后 0xc000004150 [3 2 3 0] 长度：4 容量6 main的arr2 change后 0xc000004090 [3 2 3] 长度：3 容量3 仔细观察上面代码，可以得出以下结论： Slice是值传递，因为无论是赋值还是函数传参，获取到的地址都是不一样的，%p表示获取指针 虽然是值传递，这个值是指Slice指向的结构体的值，他们仍然共享同一个底层数组，修改变量时，arr改变了，arr1和arr2都会跟着改变 注意append，当数组元素增加大于容量时，会发生扩容(扩容是2倍扩容，&gt;1000是1.5倍扩容)，这时候arr指向的数组和arr1和arr2指向的就不是同一块底层数组了。从函数退出后，arr1和arr2的元素值、长度和容量不同就可以看出来 建议如果要对传入的arr进行修改，请必须返回修改后的arr！ 示例如下： package main import &quot;fmt&quot; func changeSlice(arr []int)[]int{ fmt.Printf(&quot;changeSlice中传入的arr %p %v 长度：%d 容量%d\\n&quot;,&amp;arr,arr,len(arr),cap(arr)) arr[0]++ fmt.Printf(&quot;changeSlice中传入的arr change后 %p %v 长度：%d 容量%d\\n&quot;,&amp;arr,arr,len(arr),cap(arr)) arr=append(arr,0) fmt.Printf(&quot;changeSlice中传入的arr add后 %p %v 长度：%d 容量%d\\n&quot;,&amp;arr,arr,len(arr),cap(arr)) return arr } func main(){ arr1:=[]int{1,2,3} arr2:=arr1 fmt.Printf(&quot;main的arr1 %p %v 长度：%d 容量%d \\n&quot;,&amp;arr1,arr1,len(arr1),cap(arr1)) arr1=changeSlice(arr1) fmt.Printf(&quot;main的arr1 change后 %p %v 长度：%d 容量%d \\n&quot;,&amp;arr1,arr1,len(arr1),cap(arr1)) fmt.Printf(&quot;main的arr2 %p %v 长度：%d 容量%d\\n&quot;,&amp;arr2,arr2,len(arr2),cap(arr2)) arr2=changeSlice(arr2) fmt.Printf(&quot;main的arr2 change后 %p %v 长度：%d 容量%d\\n&quot;,&amp;arr2,arr2,len(arr2),cap(arr2)) } 输出 main的arr1 0xc000004078 [1 2 3] 长度：3 容量3 changeSlice中传入的arr 0xc0000040c0 [1 2 3] 长度：3 容量3 changeSlice中传入的arr change后 0xc0000040c0 [2 2 3] 长度：3 容量3 changeSlice中传入的arr add后 0xc0000040c0 [2 2 3 0] 长度：4 容量6 main的arr1 change后 0xc000004078 [2 2 3 0] 长度：4 容量6 main的arr2 0xc000004090 [2 2 3] 长度：3 容量3 changeSlice中传入的arr 0xc000004150 [2 2 3] 长度：3 容量3 changeSlice中传入的arr change后 0xc000004150 [3 2 3] 长度：3 容量3 changeSlice中传入的arr add后 0xc000004150 [3 2 3 0] 长度：4 容量6 main的arr2 change后 0xc000004090 [3 2 3 0] 长度：4 容量6 for range package main import &quot;fmt&quot; func main(){ arr:=[]int{1,2,3} for ind,val:=range arr{ fmt.Printf(&quot;val %p %v\\n&quot;,&amp;val,val) fmt.Printf(&quot;arr[ind] %p %v\\n&quot;,&amp;arr[ind],arr[ind]) val++ fmt.Printf(&quot;add后 val %p %v\\n&quot;,&amp;val,val) fmt.Printf(&quot;add后 arr[ind] %p %v\\n&quot;,&amp;arr[ind],arr[ind]) } } 输出 val 0xc00000a098 1 arr[ind] 0xc000012150 1 add后 val 0xc00000a098 2 add后 arr[ind] 0xc000012150 1 val 0xc00000a098 2 arr[ind] 0xc000012158 2 add后 val 0xc00000a098 3 add后 arr[ind] 0xc000012158 2 val 0xc00000a098 3 arr[ind] 0xc000012160 3 add后 val 0xc00000a098 4 add后 arr[ind] 0xc000012160 3 通过代码可以得出如下结论： for range得到的val的地址是同一个，只是每次更新值 修改val对Slice不会造成任何影响！ Map Map的Key必须是可比较的类型，Slice，channel，map不可比较，另外结构体是否可比较是根据结构体中的元素判断的。 package main import &quot;fmt&quot; func main(){ a:=make(chan int,1) b:=make(chan int,1) a&lt;-1 b&lt;-1 if a==b{ fmt.Println(&quot;可比较&quot;) } } chan虽然不报错，但是上述代码并不能得出正确的比较结果，而Slice和Map一旦作比较就报错了。 Map使用时，必须要初始化 也就是 var a map[int]int a:=make(map[]int,0) 第一个是声明，第二个是初始化 Map的Val是结构体时，一定要使用结构体指针传值，否则无法修改结构体元素 package main import &quot;fmt&quot; type person struct { name string age int } func main(){ a:=make(map[string]person) a[&quot;007&quot;]=person{&quot;小花&quot;,15} a[&quot;008&quot;]=person{&quot;小刘&quot;,18} fmt.Println(a) a[&quot;008&quot;].name=&quot;小白&quot; } 最后一行 a[&quot;008&quot;].name=&quot;小白&quot;是错的 package main import &quot;fmt&quot; type person struct { name string age int } func main(){ a:=make(map[string]*person) a[&quot;007&quot;]=&amp;person{&quot;小花&quot;,15} a[&quot;008&quot;]=&amp;person{&quot;小刘&quot;,18} fmt.Println(a) a[&quot;008&quot;].name=&quot;小白&quot; fmt.Println(a[&quot;008&quot;]) } 所以传结构体时，使用指针传递最好 Struct package main import &quot;fmt&quot; type person struct { name string age int } func changeStruct(p person){ fmt.Println(&quot;changeStruct person %p %v&quot;,&amp;p,p) p.age=17 fmt.Println(&quot;changeStruct person change后 %p %v&quot;,&amp;p,p) } func main(){ person1:=person{&quot;小刘&quot;,18} fmt.Println(&quot;main person1 %p %v&quot;,&amp;person1,person1) changeStruct(person1) fmt.Println(&quot;main person1 change后 %p %v&quot;,&amp;person1,person1) } 输出 main person1 %p %v &amp;{小刘 18} {小刘 18} changeStruct person %p %v &amp;{小刘 18} {小刘 18} changeStruct person change后 %p %v &amp;{小刘 17} {小刘 17} main person1 change后 %p %v &amp;{小刘 18} {小刘 18} 从以上可以得出： Struct是值传递，传入的只是Struct值，所以会经过值拷贝，这样也消耗很大 不如传入指针 package main import &quot;fmt&quot; type person struct { name string age int } func changeStruct(p *person){ fmt.Println(&quot;changeStruct person %p %v&quot;,&amp;p,p) p.age=17 fmt.Println(&quot;changeStruct person change后 %p %v&quot;,&amp;p,p) } func main(){ person1:=person{&quot;小刘&quot;,18} fmt.Println(&quot;main person1 %p %v&quot;,&amp;person1,person1) changeStruct(&amp;person1) fmt.Println(&quot;main person1 change后 %p %v&quot;,&amp;person1,person1) } 输出 main person1 %p %v &amp;{小刘 18} {小刘 18} changeStruct person %p %v 0xc000006030 &amp;{小刘 18} changeStruct person change后 %p %v 0xc000006030 &amp;{小刘 17} main person1 change后 %p %v &amp;{小刘 17} {小刘 17} 注：结构体指针和结构体调用成员的方法是一样的，都是p.name，当然对于结构体指针也支持（*p).name，对于结构体也支持&amp;p.name。 ","link":"https://WinterStarHu.github.io/post/go-slicemapstruct-pai-keng/"},{"title":"Go 覆盖测试","content":"cover 转载 覆盖是指测试文件对函数的覆盖率是多少 命令 go test -cover 输出 PASS coverage: 100.0% of statements ok awesomeProject/Search 0.120s 我们的覆盖率是100%，我们想看看具体的情况 命令 go test -coverprofile=coverage.out 上述命令会输出文件 读取命令 go tool cover -func=coverage.out 输出 awesomeProject/Search/Search.go:5: BinarySearch1 100.0% awesomeProject/Search/Search.go:13: BinarySearch2 100.0% total: (statements) 100.0% 但是这个很不直观，我们可以用一个更清晰的HTML页面来显示结果： 命令 go tool cover -html=coverage.out 输出 html网页，其中绿色表示覆盖的，红色表示未覆盖的 更精细的控制 这种代码级别的覆盖测试工具还有其他作用。比如它不仅仅可以告诉你一条语句是否被执行了，还可以告诉你它执行了多少次。 go test 接受 -covermode参数，一共有三种设置： set（默认）：每条语句是否被执行了？ count：每条语句被执行了多少次？ atomic：和count相似，但是能够在并行程序中精确计数（使用了 sync/atomic 包）。 可以按照上述方式重新进行测试，可以看到在html界面中不同覆盖率的语句用不同的颜色表示出来了。 命令 go test -coverprofile=coverage.out --covermode=count 读取 go tool cover -html=coverage.out 输出 参考 统计 Golang 项目的测试覆盖率 ","link":"https://WinterStarHu.github.io/post/go-fu-gai-ce-shi/"},{"title":"Go性能测试","content":"Benchmarks 在Go 单元测试中，只是验证了算法的正确性，对于算法的复杂度只是从一次结果判断，实际上，如果考虑多次的算法时间复杂度，看看算法的性能就需要使用Benchmarks。 Benchmarks的使用仍然需要在_test.go文件中，并且开头是Benchmark，形参必须是b *testing.B。 我们接着对Go 单元测试的例子中，Search_test.go文件添加如下函数 Search_test.go func BenchmarkBinarySearch1(b *testing.B) { arr:=make([]int,0) for i:=0;i&lt;100000;i++{ arr=append(arr,i) } for i:=0;i&lt;b.N;i++{ BinarySearch1(arr,rand.Int()%100000) } } func BenchmarkBinarySearch2(b *testing.B) { arr:=make([]int,0) for i:=0;i&lt;100000;i++{ arr=append(arr,i) } for i:=0;i&lt;b.N;i++{ BinarySearch2(arr,rand.Int()%100000) } } 运行时，需要加上-bench 基准函数会运行目标代码 b.N 次。在基准执行期间，会调整 b.N 直到基准测试函数持续足够长的时间。表明b.N是不确定的值，这是为了准确得到算法的性能。 对于足够长的时间，下面是指1s以上 b.N 从 1 开始，如果基准函数在 1 秒内就执行完了，那么 b.N 的值会递增以便基准函数再重新执行，即基准函数默认要运行 1 秒，如果该函数的执行时间在 1 秒内就运行完了，那么就递增 b.N 的值，重新再执行一次 命令 go test -bench=. -run=none 输出 goos: windows goarch: amd64 pkg: awesomeProject/Search cpu: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz BenchmarkBinarySearch1-8 45808 34748 ns/op BenchmarkBinarySearch2-8 92 14177941 ns/op PASS ok awesomeProject/Search 4.278s 解释 参数介绍 -bench=. ：表示的是运行所有的基准测试，. 表示全部。 -run=none:表示过滤掉单元测试，不去跑UT的cases。 输出的结果内容分析：goos: windows：表示的是操作系统是windows。 goarch: amd64：表示目标平台的体系架构是amd64。 BenchmarkBinarySearch1-8：BenchmarkBinarySearch1表示运行的函数名称； 8表示的是，运行时对应的GOMAXPROCS的值，此数字默认为启动时 Go 进程可见的 CPU 数。。 45808 ：表示的是b.N的在1s以上的值，循环执行了 45808 次。 34748ns/op：表示执行一次这个函数，消耗的时间是34748ns。 一些标志的解释 -cpu可以定制cpu的数量 命令 go test -bench=. -cpu=1,2,4 -run=none 输出 goos: windows goarch: amd64 pkg: awesomeProject/Search cpu: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz BenchmarkBinarySearch1 77134 16858 ns/op BenchmarkBinarySearch1-2 67426 17360 ns/op BenchmarkBinarySearch1-4 69294 16515 ns/op BenchmarkBinarySearch2 247 5035322 ns/op BenchmarkBinarySearch2-2 240 4969318 ns/op BenchmarkBinarySearch2-4 235 5096158 ns/op PASS ok awesomeProject/Search 9.280s 不同CPU差别不大，因为没有涉及到并行吧 -benchtime改变运行持续的时间，默认是大于1s，现在是大于10s 命令 go test -bench=. -benchtime=10s -run=none -benchtime=10s:表示的是运行时间为10s，默认的时间是1s。 输出 goos: windows goarch: amd64 pkg: awesomeProject/Search cpu: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz BenchmarkBinarySearch1-8 775342 18227 ns/op BenchmarkBinarySearch2-8 1404 7309653 ns/op PASS ok awesomeProject/Search 25.515s 通过-count 标志，可以指定基准测试多跑几次 命令 go test -bench=. -benchtime=2s -count=5 -run=none 输出 C:\\Users\\WinterStar\\go\\src\\awesomeProject\\Search&gt;go test -bench=. -benchtime=2s -count=5 -run=none goos: windows goarch: amd64 pkg: awesomeProject/Search cpu: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz BenchmarkBinarySearch1-8 160483 15417 ns/op BenchmarkBinarySearch1-8 155282 14992 ns/op BenchmarkBinarySearch1-8 149983 15191 ns/op BenchmarkBinarySearch1-8 156448 14955 ns/op BenchmarkBinarySearch1-8 161452 15440 ns/op BenchmarkBinarySearch2-8 478 5082332 ns/op BenchmarkBinarySearch2-8 492 4918752 ns/op BenchmarkBinarySearch2-8 472 5147550 ns/op BenchmarkBinarySearch2-8 459 5138692 ns/op BenchmarkBinarySearch2-8 459 5126518 ns/op PASS ok awesomeProject/Search 27.379s 耗时管理 在启动或者循环过程中，存在耗时可能会影响函数的性能测试b.ResetTimer() 函数可以用于忽略启动的累积耗时 如果在每次循环迭代中，你有一些费时的配置逻辑，要使用 b.StopTimer() 和 b.StartTimer() 函数来暂定基准测试计时器。 func BenchmarkBinarySearch1(b *testing.B) { arr:=make([]int,0) for i:=0;i&lt;100000;i++{ arr=append(arr,i) } b.ResetTimer() for i:=0;i&lt;b.N;i++{ b.StopTimer() val:=rand.Int()%100000 b.StartTimer() BinarySearch1(arr,val) } } func BenchmarkBinarySearch2(b *testing.B) { arr:=make([]int,0) for i:=0;i&lt;100000;i++{ arr=append(arr,i) } b.ResetTimer() for i:=0;i&lt;b.N;i++{ b.StopTimer() val:=rand.Int()%100000 b.StartTimer() BinarySearch2(arr,val) } } 命令 go test -bench=. -run=none 输出 goos: windows goarch: amd64 pkg: awesomeProject/Search cpu: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz BenchmarkBinarySearch1-8 66144 17916 ns/op BenchmarkBinarySearch2-8 226 4947265 ns/op PASS ok awesomeProject/Search 5.016s 可以看见时间变短了。 内存分配 内存分配的次数和分配的大小和基准测试的执行时间强相关。你可以通过在代码中增加 b.ReportAllocs() 函数来告诉 testing 框架记录内存分配的数据。 func BenchmarkBinarySearch1(b *testing.B) { b.ReportAllocs() arr:=make([]int,0) for i:=0;i&lt;100000;i++{ arr=append(arr,i) } b.ResetTimer() for i:=0;i&lt;b.N;i++{ b.StopTimer() val:=rand.Int()%100000 b.StartTimer() BinarySearch1(arr,val) } } func BenchmarkBinarySearch2(b *testing.B) { b.ReportAllocs() arr:=make([]int,0) for i:=0;i&lt;100000;i++{ arr=append(arr,i) } b.ResetTimer() for i:=0;i&lt;b.N;i++{ b.StopTimer() val:=rand.Int()%100000 b.StartTimer() BinarySearch2(arr,val) } } 命令 go test -bench=. -run=none 输出 goos: windows goarch: amd64 pkg: awesomeProject/Search cpu: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz BenchmarkBinarySearch1-8 67902 18285 ns/op 0 B/op 0 allocs/op BenchmarkBinarySearch2-8 248 4713975 ns/op 56 B/op 2 allocs/op PASS ok awesomeProject/Search 5.098s 你也可以使用 go test -benchmem 标识来强制 testing 框架打印出所有基准测试的内存分配次数 -benchmem:表示显示memory的指标。 命令 go test -bench=. -benchmem -run=none 输出 goos: windows goarch: amd64 pkg: awesomeProject/Search cpu: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz BenchmarkBinarySearch1-8 50349 23428 ns/op 0 B/op 0 allocs/op BenchmarkBinarySearch2-8 170 6705078 ns/op 56 B/op 2 allocs/op PASS ok awesomeProject/Search 5.316s 0 B/op：表示每次执行操作，分配0B的内存。 0 allocs/op：表示执行一次这个函数，分配内存的次数为1次。 收集基准测试数据 该 testing 包内置了对生成 CPU，内存和模块配置文件的支持。 -cpuprofile=$FILE 收集 CPU 性能分析到 $FILE 文件 -memprofile=$FILE,将内存性能分析写入到 $FILE 文件，-memprofilerate=N 调节采样频率为 1/N -blockprofile=$FILE,输出内部 goroutine 阻塞的性能分析文件数据到 $FILE 命令 go test -bench=. -benchmem -cpuprofile=c.p -run=none 上述命令会在当前目录下生成c.p的文件 读取文件命令 go tool pprof c.p 使用上述命令可以读取到c.p的内容，并使用protobuf交互 交互命令 top命令可以查看cpu使用情况的前几名 (pprof) top Showing nodes accounting for 2440ms, 87.14% of 2800ms total Dropped 45 nodes (cum &lt;= 14ms) Showing top 10 nodes out of 58 flat flat% sum% cum cum% 880ms 31.43% 31.43% 880ms 31.43% awesomeProject/Search.BinarySearch1 720ms 25.71% 57.14% 720ms 25.71% awesomeProject/Search.BinarySearch2.func1 400ms 14.29% 71.43% 1080ms 38.57% sort.doPivot_func 180ms 6.43% 77.86% 180ms 6.43% runtime.stdcall1 90ms 3.21% 81.07% 90ms 3.21% runtime.stdcall6 40ms 1.43% 82.50% 40ms 1.43% runtime.(*mcache).releaseAll 40ms 1.43% 83.93% 140ms 5.00% sort.insertionSort_func 30ms 1.07% 85.00% 30ms 1.07% internal/reflectlite.Swapper.func5 30ms 1.07% 86.07% 140ms 5.00% runtime.readmemstats_m 30ms 1.07% 87.14% 30ms 1.07% runtime.updateTimerPMask 解释 最后一列为函数名称，其他各项内容意义如下(转载)： flat:当前函数占用CPU的耗时 flat%:当前函数占用CPU的耗时百分比 sum%:函数占用CPU的累积耗时百分比 cum：当前函数+调用当前函数的占用CPU总耗时 cum%: 当前函数+调用当前函数的占用CPU总耗时百分比 list 函数名 可以查看函数的cpu使用情况 (pprof) list List Total: 2.80s 可以list后面跟具体的函数 (pprof) list awesomeProject/Search.BinarySearch1 Total: 2.80s ROUTINE ======================== awesomeProject/Search.BinarySearch1 in C:\\Users\\WinterStar\\go\\src\\awesomeProject\\Search\\Search.go 880ms 880ms (flat, cum) 31.43% of Total . . 1:package Search . . 2: . . 3:import &quot;sort&quot; . . 4: . . 5:func BinarySearch1(arr []int,val int) bool{ 430ms 430ms 6: for i:=0;i&lt;len(arr);i++{ 450ms 450ms 7: if arr[i]==val{ . . 8: return true . . 9: } . . 10: } . . 11: return false . . 12:} 输入web，会打开本地浏览器查看pprof的svg图来分析 注意： 这个web命令需要在生成的机器上安装graphviz 注意编译器的优化 可以看看这篇博客https://blog.csdn.net/qq_28119741/article/details/117935237 上面很多内容都参考该博客，非常感谢 ","link":"https://WinterStarHu.github.io/post/go-xing-neng-ce-shi/"},{"title":"GO 单元测试","content":"单元测试 简介 单元测试是为了对函数或者模块的功能进行测试。以往，我们在调试程序的时候，是有main函数的，在main函数中对函数进行调用，然后观察运行结果是否正确。 但是实际项目开发中，这样的操作手段存在很多隐患： 多个测试用例在main中进行调用时，为了不调用某个测试用例就需要先注释掉然后再运行main 由于在main中修改，会影响到程序主体架构，这样不利于版本的构建 所以Go引入了Testing测试框架来进行单元测试。 基本规则 为了使用Testing，需要引入Testing包。 文件名以_test.go结尾是测试文件。 在 _test.go 中编写测试用例时，函数以Test开头，且Test之后第一个字母不能是小写字母，因为go识别Test是根据驼峰命名法识别的。 运行_test.go文件的方法是在测试文件所在目录下，输入命令go test go test和go test -v的区别是前者仅在有错误的情况下才会输出详细信息(正确仅输出PASS)，后者是任何情况都会输出详细信息 例子 例子是查找数组中的值，常规方法是O(N)，而排序后使用二分法是O(NlogN)（排序算法是O(NlogN)+二分是O(logN)）。 在工程下新建Search文件夹，下面新建Search.go和Search_test.go文件 Search.go package Search import &quot;sort&quot; func BinarySearch1(arr []int,val int) bool{ for i:=0;i&lt;len(arr);i++{ if arr[i]==val{ return true } } return false } func BinarySearch2(arr []int,val int) bool{ sort.Slice(arr, func(i, j int) bool { return arr[i]&lt;arr[j] }) ind:=sort.Search(len(arr), func(i int) bool { return arr[i]&lt;val }) if ind&lt;len(arr) &amp;&amp; arr[ind]==val{ return true } return false } Search_test.go package Search import ( &quot;log&quot; &quot;testing&quot; ) func TestBinarySearch1(t *testing.T) { arr:=[]int{1,2,3,4,5} val:=5 if !BinarySearch1(arr,val){ log.Fatalln(&quot;期望返回true，实际上返回false&quot;,val) } val=6 if BinarySearch1(arr,val){ log.Fatalln(&quot;期望返回false，实际上返回true&quot;,val) } } func TestBinarySearch2(t *testing.T) { arr:=[]int{1,2,3,4,5} val:=5 if !BinarySearch2(arr,val){ log.Fatalln(&quot;期望返回true，实际上返回false&quot;) } val=6 if BinarySearch2(arr,val){ log.Fatalln(&quot;期望返回false，实际上返回true&quot;) } } 上面Search_Test.go中的log.Fatalln就可以在有错误的情况下报错，从而告知Testing框架是否PASS 命令 go test -v 输出 === RUN TestBinarySearch1 --- PASS: TestBinarySearch1 (0.00s) === RUN TestBinarySearch2 2021/08/14 16:48:09 期望返回true，实际上返回false exit status 1 FAIL awesomeProject/Search 0.305s 上述可以看见第二个用例没有通过，说明代码出现问题 那么我们在修改部分错误代码修改后（修改可以通过调试，goland是支持调试测试函数的） func BinarySearch2(arr []int,val int) bool{ sort.Slice(arr, func(i, j int) bool { return arr[i]&lt;arr[j] }) ind:=sort.Search(len(arr), func(i int) bool { return arr[i]&gt;=val }) if ind&lt;len(arr) &amp;&amp; arr[ind]==val{ return true } return false } 如果我们只想测试第二个测试用例可以使用如下命令 命令 go test -v -test.run TestBinarySearch2 输出 === RUN TestBinarySearch2 --- PASS: TestBinarySearch2 (0.00s) PASS ok awesomeProject/Search 0.323s 实际上，如果在目录下存在多个测试用例文件，我们还可以指定测试文件，注意一定要带上测试的源文件 命令 go test -v Search_test.go Search.go 输出 === RUN TestBinarySearch1 --- PASS: TestBinarySearch1 (0.00s) === RUN TestBinarySearch2 --- PASS: TestBinarySearch2 (0.00s) PASS ok command-line-arguments 0.258s 上面的输出标出了几个时间，虽然看起来两个函数运行时间都是0.00s(太快以至于可以忽略不计)但是最后总时间是0.258s，这是因为Testing测试框架运行还需要时间。 如果我将测试用例改为如下： func TestBinarySearch1(t *testing.T) { arr:=[]int{1,2,3,4,5} for i:=0;i&lt;100000;i++{ arr=append(arr,i) } val:=99999 if !BinarySearch1(arr,val){ log.Fatalln(&quot;期望返回true，实际上返回false&quot;) } val=100000 if BinarySearch1(arr,val){ log.Fatalln(&quot;期望返回false，实际上返回true&quot;) } } func TestBinarySearch2(t *testing.T) { arr:=[]int{1,2,3,4,5} for i:=0;i&lt;100000;i++{ arr=append(arr,i) } val:=99999 if !BinarySearch2(arr,val){ log.Fatalln(&quot;期望返回true，实际上返回false&quot;) } val=100000 if BinarySearch2(arr,val){ log.Fatalln(&quot;期望返回false，实际上返回true&quot;) } } 命令 go test -v Search_test.go Search.go 输出 === RUN TestBinarySearch1 --- PASS: TestBinarySearch1 (0.01s) === RUN TestBinarySearch2 --- PASS: TestBinarySearch2 (0.06s) PASS ok command-line-arguments 0.389s 可以看出时间的差别。 ","link":"https://WinterStarHu.github.io/post/go-dan-yuan-ce-shi/"},{"title":"GO JSON序列化和反序列化","content":"Go JSON序列化和反序列化 JSON格式 JSON语法检查网址: www.json.cn 如下所示，JSON的键值对的键必须以&quot;&quot;双引号包裹，也就是key的类型必须是string，而val则随意。 [ { &quot;name&quot;:&quot;小花&quot;, &quot;age&quot;:&quot;10&quot;, &quot;adderss&quot;:&quot;中国&quot; }, { &quot;name&quot;:&quot;小刘&quot;, &quot;age&quot;:10, &quot;address&quot;:[ 0, 1 ] } ] 序列化 encoding/json包 对上面的json数据，为了在go语言中构造，我们使用了[]map[string]interface这种slice，就能够得到上述一致的内容 package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main(){ jsonSlice:=make([]map[string]interface{},0) jsonSlice=append(jsonSlice,make(map[string]interface{})) jsonSlice[0][&quot;name&quot;]=&quot;小花&quot; jsonSlice[0][&quot;age&quot;]=&quot;10&quot; jsonSlice[0][&quot;address&quot;]=&quot;中国&quot; jsonSlice=append(jsonSlice,make(map[string]interface{})) jsonSlice[1][&quot;name&quot;]=&quot;小刘&quot; jsonSlice[1][&quot;age&quot;]=10 jsonSlice[1][&quot;address&quot;]=[]int{0,1} jsonString,err:=json.Marshal(jsonSlice) if err!=nil{ fmt.Println(&quot;error&quot;) } fmt.Println(string(jsonString)) } 输出 [{&quot;address&quot;:&quot;中国&quot;,&quot;age&quot;:&quot;10&quot;,&quot;name&quot;:&quot;小花&quot;},{&quot;address&quot;:[0,1],&quot;age&quot;:10,&quot;name&quot;:&quot;小刘&quot;}] 但是由于map可能存在不同的顺序(后文运行结果好像为字典序)，所以输出顺序和上面json输出的不一样，因此我们可以使用结构体来构造，得到一致的顺序 注意 Stuct中只有导出字段(首字母大写的)才可以转换为json，未导出的会被忽略！！！ package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) type person struct { Name string Age interface{} Address interface{} id string } func main(){ jsonSlice:=make([]*person,0) jsonSlice=append(jsonSlice,&amp;person{&quot;小花&quot;,&quot;10&quot;,&quot;中国&quot;,&quot;12345&quot;}) jsonSlice=append(jsonSlice,&amp;person{&quot;小刘&quot;,10,[]int{0,1},&quot;007&quot;}) jsonString,err:=json.Marshal(jsonSlice) if err!=nil{ fmt.Println(&quot;error&quot;) } fmt.Println(string(jsonString)) } 输出 [{&quot;Name&quot;:&quot;小花&quot;,&quot;Age&quot;:&quot;10&quot;,&quot;Address&quot;:&quot;中国&quot;},{&quot;Name&quot;:&quot;小刘&quot;,&quot;Age&quot;:10,&quot;Address&quot;:[0,1]}] 如上输出，结构体里的id没有输出，我们可以把这个认为是私有的 序列化中key-val的对应关系 普通类型 在对非key-value这种对应关系的变量，如int，float，序列化以后也就只是转字符串而已，并不会按照键值对那样对应，这样得到的结果是没有意义的 结构体 把成员变量名当成key，成员变量的值当成val 使用tag来设置导出的key不是成员变量名 比如，中国人喜欢中文，那么将key设置为中文不是更容易理解 package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) type person struct { Name string `json:&quot;名字&quot;` Age interface{} `json:&quot;年龄&quot;` Address interface{} `json:&quot;地址&quot;` id string } func main(){ jsonSlice:=make([]*person,0) jsonSlice=append(jsonSlice,&amp;person{&quot;小花&quot;,&quot;10&quot;,&quot;中国&quot;,&quot;12345&quot;}) jsonSlice=append(jsonSlice,&amp;person{&quot;小刘&quot;,10,[]int{0,1},&quot;007&quot;}) jsonString,err:=json.Marshal(jsonSlice) if err!=nil{ fmt.Println(&quot;error&quot;) } fmt.Println(string(jsonString)) } 输出 [{&quot;名字&quot;:&quot;小花&quot;,&quot;年龄&quot;:&quot;10&quot;,&quot;地址&quot;:&quot;中国&quot;},{&quot;名字&quot;:&quot;小刘&quot;,&quot;年龄&quot;:10,&quot;地址&quot;:[0,1]}] map key-val一致 反序列化 将json字符串反序列化为go中的类型 仍然以开头的json字符串为例，分别反序列化为[]map[string]interface和[]struct 下面引入了两种map，看看分别转换的情况 package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main(){ jsonString:=`[{&quot;name&quot;:&quot;小花&quot;,&quot;age&quot;:&quot;10&quot;,&quot;address&quot;:&quot;中国&quot;},{&quot;name&quot;:&quot;小刘&quot;,&quot;age&quot;:10,&quot;address&quot;:[0,1]}]` var p1 []map[string]interface{} err:=json.Unmarshal([]byte(jsonString),&amp;p1) if err!=nil{ fmt.Println(&quot;p1:&quot;,err) } fmt.Println(&quot;p1:&quot;,p1) var p2 []map[int]interface{} err=json.Unmarshal([]byte(jsonString),&amp;p2) if err!=nil{ fmt.Println(&quot;p2:&quot;,err) } fmt.Println(&quot;p2:&quot;,p2) } 输出 p1: [map[address:中国 age:10 name:小花] map[address:[0 1] age:10 name:小刘]] p2: json: cannot unmarshal number name into Go value of type int p2: [map[] map[]] 由此可见，map的key类型是必须固定的，固定为string类型，否则就会报错 下面分别引入了不同的结构体，通过输出说明什么样的结构体才能成功的反序列化 package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) type person1 struct { Name string Age interface{} Address interface{} } type person2 struct { name string age interface{} address interface{} } type person3 struct { Naem string Age interface{} Address interface{} } type person4 struct { Name string Age interface{} Address interface{} Id string } type person5 struct { Name int Age interface{} Address interface{} id string } func main(){ jsonString:=`[{&quot;name&quot;:&quot;小花&quot;,&quot;age&quot;:&quot;10&quot;,&quot;address&quot;:&quot;中国&quot;},{&quot;name&quot;:&quot;小刘&quot;,&quot;age&quot;:10,&quot;address&quot;:[0,1]}]` var p1 []person1 err:=json.Unmarshal([]byte(jsonString),&amp;p1) if err!=nil{ fmt.Println(&quot;p1:&quot;,err) } fmt.Println(&quot;p1:&quot;,p1) var p2 []person2 err=json.Unmarshal([]byte(jsonString),&amp;p2) if err!=nil{ fmt.Println(&quot;p2:&quot;,err) } fmt.Println(&quot;p2:&quot;,p2) var p3 []person3 err=json.Unmarshal([]byte(jsonString),&amp;p3) if err!=nil{ fmt.Println(&quot;p3:&quot;,err) } fmt.Println(&quot;p3:&quot;,p3) var p4 []person4 err=json.Unmarshal([]byte(jsonString),&amp;p4) if err!=nil{ fmt.Println(&quot;p4:&quot;,err) } fmt.Println(&quot;p4:&quot;,p4) var p5 []person5 err=json.Unmarshal([]byte(jsonString),&amp;p5) if err!=nil{ fmt.Println(&quot;p5:&quot;,err) } fmt.Println(&quot;p5:&quot;,p5) } 输出 p1: [{小花 10 中国} {小刘 10 [0 1]}] p2: [{ &lt;nil&gt; &lt;nil&gt;} { &lt;nil&gt; &lt;nil&gt;}] p3: [{小花 10 中国} {小刘 10 [0 1]}] p31: [{小花 10 中国} {小刘 10 [0 1]}] p4: [{小花 10 中国 } {小刘 10 [0 1] }] p5: json: cannot unmarshal string into Go struct field person5.Name of type int p5: [{0 10 中国 } {0 10 [0 1] }] person1是绝对合法的， person2未导出所以就不能反序列化成功，但是不会报错， person3的Naem，导致一个key不匹配，所以就忽略这个字段，不报错 person31的Naem虽然不匹配，但是tag是匹配的，所以会使用这个字段进行匹配 person4多了一个字段，所以也忽略这个字段，不报错 person5的Name类型是int类型，和json字符串中的string类型是不符合的，会报错 总结 序列化和反序列化包为encoding/json 函数可以使用Marshal和Unmarshal 理论上go里面的所有类型都可以序列化，但是结构体，map序列化较有意义 结构体的非导出字段不进行序列化 结构体如果定义了tag，那么序列化的key就是tag 反序列化一定要注意字段的类型匹配，否则会报错； 结构体的非导出字段不进行反序列化 名称不匹配的结构体或结构体中多出的字段会忽略，不报错 结构体中如果定义了tag，那么反序列化的key也会和tag进行匹配 ","link":"https://WinterStarHu.github.io/post/go-json-xu-lie-hua-he-fan-xu-lie-hua/"},{"title":"Go语言的背景知识","content":"从黑马Go语言《Go语言与区块链》看见的背景知识 开发史 应用 区块链 两个主流区块链底层系统：以太坊(智能合约)和Hyperledger Fabric ","link":"https://WinterStarHu.github.io/post/go-yu-yan-de-bei-jing-zhi-shi/"},{"title":"2021年02月22日Leetcode题解","content":"766托普利茨矩阵 766 托普利茨矩阵 两种方案： 先遍历矩阵的第一行对应的对角线上元素，再遍历矩阵的第一列对应的对角线上的元素，当存在有值不相等时返回false，否则返回true即可得到答案。 切片比较，将上一行元素的切片与下一行元素的右下切片比较 ","link":"https://WinterStarHu.github.io/post/2021-nian-02-yue-2-ri-leetcode-ti-jie/"},{"title":"C++ 相关","content":"C++相关 环境配置 推荐使用vscode，并使用[AutoVsCEnv_WPF(https://github.com/SDchao/AutoVsCEnv_WPF/releases/latest)一键配置vscode环境 参考 20秒 一键配置 VSCode (Visual Studio Code) C/C++开发环境 ! ","link":"https://WinterStarHu.github.io/post/c-xiang-guan/"},{"title":"Anaconda相关命令","content":"Anaconda使用帮助 Anaconda创建环境 创建新环境 conda create -n &quot;名字&quot; python=3.6 删除环境 conda remove -n &quot;名字&quot; --all 激活环境 conda activate &quot;名字&quot; 关闭环境 conda deactivate &quot;名字&quot; pip安装 使用镜像安装，举例如下： pip install absl-py==0.7.1 -i https://pypi.mirrors.ustc.edu.cn/simple/ 国内镜像 阿里云 中国科技大学 豆瓣(douban) 清华大学 中国科学技术大学 ","link":"https://WinterStarHu.github.io/post/anaconda-xiang-guan-ming-ling/"},{"title":"tensorflow学习历程","content":"tensorflow相关 安装 推荐使用Anaconda安装独立环境，使用国内镜像离线下载后本地离线安装，如清华镜像 ","link":"https://WinterStarHu.github.io/post/tensorflow-xue-xi-li-cheng/"},{"title":"pytorch学习历程","content":"pytoch有关 安装 推荐使用Anaconda安装独立环境，使用国内离线镜像，如清华镜像 注意torch和torchvision都需要安装 ","link":"https://WinterStarHu.github.io/post/pytorch-xue-xi-li-cheng/"},{"title":"LeetCode优化方式","content":"观察代码差异，看看如何降低复杂度和内存。 最重要的是追求时间复杂度和空间复杂度最好，而不是追求代码编写方式导致的差异 以下是两数之和，思想均是判断数组中的值与target的差是否在map中，如果不在就添加至map，在的话就返回。但是两种不同的编写方式却会导致执行用时有差异。 func twoSum(nums []int, target int) []int { dMap := make(map[int]int) for idx,val := range nums{ minus := target-val if _,ok := dMap[minus];ok { return []int{dMap[minus],idx} }else { dMap[val]=idx } } return nil } 执行用时：0 ms 内存消耗：3 MB func twoSum(nums []int, target int) []int { var dMap = make(map[int]int) for idx, val := range nums { _, ok := dMap[target-val] if ok { return []int{idx, dMap[target-val]} } else { dMap[val] = idx } } return nil } 执行用时：8 ms 内存消耗：3 MB ","link":"https://WinterStarHu.github.io/post/leetcode-you-hua-fang-shi/"},{"title":"Go HelloWorld-2","content":"入门篇 day2 😁 规则学习 匿名函数 函数作为函数变量使用，甚至可以直接在函数参数声明匿名函数。 即将函数作为参数使用 展开查看示例代码 ``` package main import ( \"fmt\" \"math\" ) func main() { // 调用函数，对每个元素进行求平方根操作 arr := []float64{1, 9, 16, 25, 30} visit(arr, func(v float64) {v = math.Sqrt(v); fmt.Printf(\"%.2f \\n\", v)}) // 调用函数，对每个元素进行求平方根操作 visit(arr, func(v float64) {v = math.Pow(v, 2);fmt.Printf(\"%.0f \\n\", v)}) } // 定义一个函数，遍历切片元素，对每个元素进行处理 func visit(list []float64, f func(float64)) { for _, value := range list { f(value) } } ``` 闭包 函数的返回值是一个函数，闭包描述了数据的行为。因为外层函数返回值是一个函数，所以虽然调用的外层函数被释放了，但是内层函数没有释放，且内层函数所使用的变量也没有释放。 闭包分析示例 闭包(closure): 一个外层函数中，有内层函数，回操作外层函数的局部变量(外层函数中的参数，或者外层函数中直接定义的变量)。 并且外层函数的返回值就是这个内层函数。 这个内层函数和外层函数的局部变量，统称为闭包结构。 局部变量的生命周期会发生改变，正常的局部变量随着函数调用而创建，随着函数的结束而销毁 但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还要继续使用 展开查看示例代码 ``` package main import \"fmt\" func main() { res1 := increment() fmt.Printf(\"%T\\n\",res1) //func() int fmt.Println(res1) v1:=res1() fmt.Println(v1) //1 v2:=res1() fmt.Println(v2) //2 res2 := increment() fmt.Println(res2) v3 := res2() fmt.Println(v3) //1 fmt.Println(res1()) //3 fmt.Println(res2()) //2 } func increment() func() int{ //外层函数 i := 0 fun := func() int{ //内层函数 i++ return i } return fun } ``` ## 值传递和引用传递的细节问题 Go语言中所有的传参都是值传递（传值），都是一个副本。副本的内容有的是值类型（int、string、bool、array、struct 属于值类型），这样在函数中就无法修改原内容数据；有的是引用类型（pointer、slice、map、chan 属于引用类型），这样就可以修改原内容数据。 是否可以修改原内容数据，和传值、传引用没有必然的关系。在 C++ 中，传引用肯定是可以修改原内容数据的；在Go语言里，虽然只有传值，但是也可以修改原内容数据，因为参数可以是引用类型。 传引用和引用类型是两个概念。虽然Go语言只有传值一种方式，但是可以通过传引用类型变量达到与传引用一样的效果。 值类型：进行值传递的数据类型也叫值类型，存储的是数值本身。 将数据类型传递给其他的变量，传递的是数据的副本(备份) int，float，string，bool，array 引用类型：理解为存储的数据的内存地址 slice，map。。 参考 Go语言（Golang）教程 千峰教育 go语言视频教程 闭包 视频讲解 ","link":"https://WinterStarHu.github.io/post/go-helloworld-2/"},{"title":"Go HelloWorld-1","content":"入门篇😀 环境配置 安装Go和GoLand jetBrains旗下所有产品均可通过教育邮箱(edu.cn)免费获取专业版。 常用快捷键记忆 快捷键 说明 Ctrl + Alt + L 格式化代码 规则学习 Go语言变量多重赋值 方式一 var a int = 10 var b int = 20 b, a = a, b 方式二 这种方式是使用异或实现的 在计算机刚发明时，内存非常“精贵”。这种变量交换往往是非常奢侈的。于是计算机“大牛”发明了一些算法来避免使用中间变量 var a int = 100 var b int = 200 a = a ^ b b = b ^ a a = a ^ b fmt.Println(a, b) 反引号书写多行字符串 双引号书写字符串被称为字符串字面量（string literal），这种字面量不能跨行； 多行字符串需要使用反引号`，多用于内嵌源码和内嵌数据； 在反引号中的所有代码不会被编译器识别，而只是作为字符串的一部分。 展开查看示例代码 package main import \"fmt\" func main() { var temp string temp = ` x := 10 y := 20 z := 30 fmt.Println(x, \" \", y, \" \", z) x, y, z = y, z, x fmt.Println(x, \" \", y, \" \", z) ` fmt.Println(temp) } rune定义Unicode字符 使用 fmt.Printf 中的%T动词可以输出变量的实际类型 package main import &quot;fmt&quot; func main() { var a byte = 'a' fmt.Printf(&quot;%d %T\\n&quot;, a, a) var b rune = '你' fmt.Printf(&quot;%d %T\\n&quot;, b, b) } Go语言使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。 Unicode 和 ASCII 都是一种字符集，字符集为每个字符分配一个唯一的 ID，我们使用到的所有字符在 Unicode 字符集中都有唯一的一个 ID 对应，例如上面例子中的 a 在 Unicode 与 ASCII 中的编码都是 97。“你”在 Unicode 中的编码为 20320，但是在不同国家的字符集中，“你”的 ID 会不同。而无论任何情况下，Unicode 中的字符的 ID 都是不会变化的。 UTF-8 是编码规则，将 Unicode 中字符的 ID 以某种方式进行编码。UTF-8 的是一种变长编码规则，从 1 到 4 个字节不等。编码规则如下： 0xxxxxx 表示文字符号 0～127，兼容 ASCII 字符集。 从 128 到 0x10ffff 表示其他字符。 根据这个规则，拉丁文语系的字符编码一般情况下，每个字符依然占用一个字节，而中文每个字符占用 3 个字节。 类型 字节数 说明 byte 1 表示 UTF-8 字符串的单个字节的值，uint8 的别名类型 rune 4 表示单个 unicode 字符，int32 的别名类型 fmt格式化输出 table th:first-of-type { width: 20%; } table th:nth-of-type(2) { width: 80%; } } 输出格式 输出内容 %v 值的默认格式表示 %+v 类似 %v，但输出结构体时会添加字段名 %#v 值的 Go 语法表示 %Т 值的类型的 Go 语法表示 %t 单词 true 或 false %b 表示为二进制 %c 该值对应的 unicode 码值 %d 表示为十进制 %8d 表示该整型长度是 8，不足 8 则在数值前补空格；如果超出 8，则以实际为准 %08d 表示该整型长度是 8，不足 8 则在数值前补 0；如果超出 8，则以实际为准 %o 表示为八进制 %q 该值对应的单引号括起来的Go语言语法字符字面值，必要时会采用安全的转义表示 %x 表示为十六进制，使用 a~f %X 表示为十六进制，使用 A~F %U 表示为 unicode 格式：U+1234，等价于 U+%04X %b 无小数部分、二进制指数的科学计数法，如 -123456p-78 %e （=%.6e）有 6 位小数部分的科学计数法，如 -1234.456e+78 %E 科学计数法，如 -1234.456E+78 %f （=%.6f）有 6 位小数部分，如 123.456123 %F 等价于 %f %g 根据实际情况采用 %e 或 %f 格式（获得更简洁、准确的输出） %G 根据实际情况采用 %E 或 %F 格式（获得更简洁、准确的输出） %s 直接输出字符串或者字节数组 %q 该值对应的双引号括起来的Go语法字符串字面值，必要时会采用安全的转义表示 %x 每个字节用两字符十六进制数表示，使用 a~f %X 每个字节用两字符十六进制数表示，使用 A~F 展开查看示例代码 package main import \"fmt\" func main() { str := \"steven\" fmt.Printf(\"%T, %v \\n\", str, str) var a rune = '一' fmt.Printf(\"%T, %v \\n\", a, a) var b byte = 'b' fmt.Printf(\"%T, %v \\n\", b, b) var c int32 = 98 fmt.Printf(\"%T, %v \\n\", c, c) var flag bool fmt.Printf(\"%T, %t \\n\", flag, flag) flag = true fmt.Printf(\"%T, %t \\n\", flag, flag) fmt.Printf(\"%T, %d \\n\", 123, 123) fmt.Printf(\"%T, %5d \\n\", 123, 123) fmt.Printf(\"%T, %05d \\n\", 123, 123) fmt.Printf(\"%T, %b \\n\", 123, 123) fmt.Printf(\"%T, %o \\n\", 123, 123) fmt.Printf(\"%T, %c \\n\", 97, 97) fmt.Printf(\"%T, %q \\n\", 97, 97) fmt.Printf(\"%T, %x \\n\", 123, 123) fmt.Printf(\"%T, %X \\n\", 123, 123) fmt.Printf(\"%T, %U \\n\", '一', '一') fmt.Printf(\"%b \\n\", 123.123456) fmt.Printf(\"%f \\n\", 123.1) fmt.Printf(\"%.2f \\n\", 123.125456) fmt.Printf(\"%e \\n\", 123.123456) fmt.Printf(\"%E \\n\", 123.123456) fmt.Printf(\"%.1e \\n\", 123.123456) fmt.Printf(\"%F \\n\", 123.123456) fmt.Printf(\"%g \\n\", 123.123456) fmt.Printf(\"%G \\n\", 123.123456) var value complex64 = 2.1 + 12i value2 := complex(2.1, 12) fmt.Println(real(value)) fmt.Println(imag(value)) fmt.Println(value2) arr := []byte{'x', 'y', 'z', 'z'} fmt.Printf(\"%s \\n\", \"欢迎访问微学苑\") fmt.Printf(\"%q \\n\", \"欢迎访问微学苑\") fmt.Printf(\"%x \\n\", \"欢迎访问微学苑\") fmt.Printf(\"%X \\n\", \"欢迎访问微学苑\") fmt.Printf(\"%T, %s \\n\", arr, arr) fmt.Printf(\"%T, %q \\n\", arr, arr) fmt.Printf(\"%T, %x \\n\", arr, arr) fmt.Printf(\"%T, %X \\n\", arr, arr) } iota iota 是特殊常量值，是一个系统定义的可以被编译器修改的常量值。iota 只能被用在常量的赋值中，在每一个 const 关键字出现时，被重置为 0，然后每出现一个常量，iota 所代表的数值会自动增加 1。iota 可以理解成常量组中常量的计数器，不论该常量的值是什么，只要有一个常量，那么 iota 就加 1。 package main import &quot;fmt&quot; const ( a = iota b = iota c = iota ) func main() { fmt.Println(a, b, c) } 常量组中如果不指定类型和初始值，则与上一行非空常量的值相同。所以上述的枚举可以简写，如下所示： package main import &quot;fmt&quot; const ( a = iota b c ) func main() { fmt.Println(a, b, c) } 运算符 table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 60%; } table th:nth-of-type(3) { width: 30%; } 运算符 描述 实例 + 相加 A+B 输出结果 30 - 相减 A-B 输出结果 -10 * 相乘 A*B 输出结果 200 / 相除 B/A 输出结果 2 % 求余 B%A 输出结果 0 ++ 自增 A++ 输出结果 11 -- 自减 A-- 输出结果 9 == 检查两个值是否相等，如果相等返回 True 否则返回 False (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True否则返回 False (A != B) 为 True &gt; 检查左边值是否大于右边值，如果是返回 True否则返回 False (A &gt; B) 为 False &lt; 检查左边值是否小于右边值，如果是返回 True 否则返回 False (A &lt; B) 为 True &gt;= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False (A &gt;= B) 为 False &lt;= 检查左边值是否小于等于右边值，如果是返回 True否则返回 False (A &lt;= B) 为 True &amp;&amp; 逻辑 AND 运算符。如果两边的操作数都是 True，则条件 True，否则为 False (A &amp;&amp; B) 为 False ! 逻辑 NOT 运算符。如果条件为 True，则逻辑 NOT 条件 False，否则为 True !(A &amp;&amp; B) 为 True &amp; 按位与运算符&quot;&amp;&quot;是双目运算符。其功能是参与运算的两数各对应的二进制位相与 (A&amp;B) 结果为 12，二进制为 0000 1100 按位或运算符“ ^ 按位异或运算符“^”是双目运算符。其功能是参与运算的两数各对应的二进制位相异或，当两对应的二进制位相异时，结果为 1 (A^B) 结果为 49，二进制为 0011 0001 &lt;&lt; 左移运算符“&lt;&lt;”是双目运算符。左移 n 位就是乘以 2 的 n 次方。其功能是把“&lt;&lt;”左边的运算数的各二进制位全部左移若干位，由“&lt;&lt;”右边的数指定移动的位数，高位舍弃，低位补 0 (A&lt;&lt;2) 结果为 240，二进制 1111 0000 &gt;&gt; 右移运算符“&gt;&gt;”是双目运算符。右移 n 位就是除以 2 的 n 次方。其功能是把“&gt;&gt;”左边的运算数的各二进制位全部右移若干位，“&gt;&gt;”右边的数指定移动的位数 (A&gt;&gt;2) 结果为 15，二进制为 0000 1111 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C=A+B 将 A+B 表达式结果赋值给 C += 相加后再赋值 C+=A 等于 C=C+A -= 相减后再赋值 C-=A 等于 C=C-A *= 相乘后再赋值 C*=A 等于 C=C*A /= 相除后再赋值 C/=A 等于 C=C/A %= 求余后再赋值 C%=A 等于 C=C%A &lt;&lt;= 左移后赋值 C&lt;&lt;=2 等于 C=C&lt;&lt;2 &gt;&gt;= 右移后赋值 C&gt;&gt;=2 等于 C=C&gt;&gt;2 &amp;= 按位与后赋值 C&amp;=2 等于 C=C&amp;2 ^= 按位异或后赋值 C^=2 等于 C=C^2 | = 按位或后赋值 C | =2 等于 C=C | 2 运算符优先级 优先级 运算符 7 ^ ! 6 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 5 + - 4 == != &lt; &lt;= &gt;= &gt; 3 &lt;- 2 &amp;&amp; 1 | | Go和C++相比所具有的区别 布尔类型不能接受其他类型的赋值，也不支持自动或强制的类型转换。 Go语言是强类型语言，变量类型一旦确定，就不能将其他类型的值赋值给该变量。 var b bool b = 1 // 编译错误 b = bool(1) // 编译错误 b = (1!=0) // 编译正确 由于强类型的缘故，Go语言在进行布尔值真假判断时，对值的类型有严格限制，不同类型的值不能直接使用==或!=运算符进行比较，否则就会报错。同样，!运算符也不能作用于非布尔类型值。 b := (false == 0); // cannot convert 0 (type untyped number) to type bool invalid operation: false == 0 (mismatched types bool and int) 在Go语言中，不允许字符串转 int!! 但是Go支持数据类型转换的有： 浮点型与整型之间的转换 整数类型转字符串类型 这种类型的转换，其实相当于 byte 或 rune 转 string。int 数值是 ASCII 码的编号或 unicode 字符集的编号，转成 string 就是根据字符集，将对应编号的字符查找出来。当该数值超出 unicode 编号范围，则转成的字符串显示为乱码。例如，19968 转 string，就是“一”。 备注： ASCII 字符集中数字的十进制范围是 48～57； ASCII 字符集中大写字母的十进制范围是 65～90； ASCII 字符集中小写字母的十进制范围是 97～122； unicode 字符集中汉字的范围是 4e00～9fa5，十进制范围是 19968～40869。 switch switch 语句执行的过程是自上而下的，直到找到 case 匹配项，匹配项中无须使用 break，因为Go语言中的 switch 默认给每个 case 自带 break。因此匹配成功后不会向下执行其他的 case 分支，而是跳出整个 switch。可以添加 fallthrough（中文含义是：贯穿），强制执行后面的 case 分支。fallthrough 必须放在 case 分支的最后一行。如果它出现在中间的某个地方，编译器就会报错。 switch 后的表达式可以省略，默认是 switch true。 参考 Go安装包下载 GoLand下载 安装并免费使用Pychram专业版（学生/教师） Go安装与Goland破解永久版 Go语言（Golang）教程 Go Lang 异或符 ASCII 千峰教育 go语言视频教程 ","link":"https://WinterStarHu.github.io/post/go-helloworld-1/"},{"title":"MATLAB project的使用","content":"matlab project竟然是2019才提出来的概念。那么如何使用呢？ MATLAB工程介绍可以参考官方介绍 创建工程 首先是如何创建工程 要创建空白工程，请在主页选项卡上，点击新建 &gt; 工程 &gt; 空白工程。要从现有文件夹创建工程，请在主页选项卡上，点击新建 &gt; 工程 &gt; 从文件夹。 将打开“新建工程”对话框。输入工程名称，选择工程文件夹，然后点击创建。 设置路径 然后是设置路径 上传到github 将Matlab工程共享到Github 一些名词的理解 工程路径的作用 设置工程路径后，该路径文件夹会由灰色变成黑色，而不在工程路径中的文件仍然是灰色，这样可以将代码文件和由代码生成的文件分开！ 在所有中，不在工程中 对于一些matlab的数据文件，比较大，如果把这些都上传到github，那么你很有可能超出github的容量限制，所以可以把这些文件放在工程里而不将他们添加到工程路径中 在工程中，在所有中，不在工程路径中 对于一些非代码文件，比如readme所需要的图片文件等等，和你的代码无关，那么没有必要在matlab的路径中，因为不需要运行，但是又需要设置在github中存在，便于观看，那么这就是一个方法。 再次理一下关系 所有：project目录下包含的所有文件 工程：代码运行所必须的文件和需github上传的文件 工程路径：代码运行所必须的文件，建议这上传到github，便于再次下载代码的完整性 所以 所有&gt;工程&gt;工程路径 尝试是最好的帮手 依存关系分析 不同的写法会导致不同的显示 对于load： file_in = 'AGC_attenuation_values.mat'; load(file_in,'nom_attenuation') 这种写法会导致matlab里依存关系不能体现出来，而 load AGC_attenuation_values.mat nom_attenuation 这种写法，将变量体现出来，就可以实现依存关系的体现。 ","link":"https://WinterStarHu.github.io/post/matlab-project-de-shi-yong/"},{"title":"Matlab设置默认打开路径","content":"有些路径是我们常用的，那么如何设置默认打开路径呢 本文另外介绍了一个matlab project 右击MATLAB的快捷方式，修改起始位置对应的路径，重启后即可实现 其他1 发现，搜索“matlab project”可以发现很多和matlab有关的代码哦 matlab project code matlab project matlab-code 1000project verysource matlab solution 知乎： 如何学好matlab 其他2 matlab project竟然是2019才提出来的概念。 ","link":"https://WinterStarHu.github.io/post/matlab-she-zhi-mo-ren-da-kai-lu-jing/"},{"title":"Matlab上传到GItHub","content":"将Matlab工程共享到Github 之前看见两篇matlab的官方文档有点糊涂，后来才明白有上传和下载： 设置 Git 源代码管理 如果您将某个现有工程添加到 Git 源代码管理中，将在该沙盒中创建一个本地 Git 存储库。您可以稍后指定远程存储库。请参阅Add a Project to Source Control。 要通过克隆远程 Git 存储库来创建工程，请在 MATLAB® 的“主页”选项卡上选择新建 &gt; 工程 &gt; 从 Git。当您指定要从中检索的远程存储库后，将创建一个本地存储库。您还可以从远程存储库取回或提取更改，也可以将更改推送到远程存储库。请参阅Clone Git Repository or Check Out SVN Repository。 在 GitHub 上共享工程 主页上显示的是英文，所以这里翻译其中的一些词 加载工程后，在 Project[工程] 选项卡上，选择 Share[共享] &gt; Change Share Options[更改共享选项]。 将 GitHub 选项添加到 Share[共享] 菜单中。在 Manage Sharing [管理共享]对话框中，选择 GitHub，然后点击 Close[关闭]。 选择 Share[共享] &gt; GitHub。 在 Create GitHub Repository [创建githu仓库]对话框中，输入您的 GitHub 用户名[xxx@xxx.com]和密码，然后编辑新存储库的名称。点击 Create[创建]。 将出现一则警告，提示您确认是否要创建公共存储库并修改当前工程的远程存储库位置。要继续，请点击 Yes。 Create GitHub Repository 对话框将显示新存储库的 URL 地址。点击该链接可在 GitHub 网站上查看新存储库。存储库包含工程文件的初始签入。 当前工程中的源代码管理现在引用 GitHub 上的新存储库作为远程存储库。要使用具有新存储库的工程，请在 Create GitHub Repository 对话框中点击 Reload Project。 我觉得这个功能还是很好用的，至于版本回退什么的，我觉得github下载历史版本--xdd这个更好用一点。然后覆盖当前文件。 另外也可以直接使用MATLAB克隆下来，我没尝试过。 使用feature('locale')在matlab命令行窗口可以看出来中文基本上都是GBK编码，然而github都是utf-8编码，那么还是用英文的写readme比较好，这样不至于是英文。 至于设置库为私有，可参考github设置仓库可见性 私人仓库设置他人协作/可见设置后仍然可上传，同步等等操作。 偶然发现不使用过程也可以实现源代码控制这篇还是很明确的。 ","link":"https://WinterStarHu.github.io/post/matlab-shang-chuan-dao-github/"},{"title":"easygui库中参数修改","content":"修改easygui库，实现字体，颜色，背景的改变 问题描述 在使用buttonbox时，发现文字显示太小，还需要加粗，而我是要用来作为显示释义的窗口，见上一帖（小E教你学英语） 而网上说的办法不适用于buttonbox，于是我去找起了源码buttonbox.py，我发现它是使用tkinter写的，之前听小甲鱼说过，这个也是一款gui的工具。 下面是我修改的其中一个地方（By WINTERSTAR） # self.boxFont = tk_Font.Font( # family='global_state.PROPORTIONAL_FONT_FAMILY', # size=global_state.PROPORTIONAL_FONT_SIZE) # add By WINTERSTAR self.boxFont = tk_Font.Font( family='Microsoft YaHei', size=12, weight='bold') # self.boxFont = tk_Font.nametofont(&quot;TkFixedFont&quot;) 但是改了以后依旧不能用，记录python-tkinter包 Text控件中的更改文字颜色大小操作 在看过链接博客以后，发现是因为这个参数压根没传到后面，只是在一个函数里使用了。因此仿照博客的写法 同时我发现还能改字体 中文字体的英文名称（宋体 微软雅黑） 在buttonbox.py里，发现self.create_msg_widget(msg)所调用的一个函数是对释义区域进行实现的代码： # Methods to change content --------------------------------------- def set_msg(self, msg): self.messageArea.config(state=tk.NORMAL) self.messageArea.delete(1.0, tk.END) self.messageArea.insert(tk.END, msg) self.messageArea.config(state=tk.DISABLED) self.messageArea.config(font=self.boxFont) #By WINTERSTAR # Adjust msg height self.messageArea.update() numlines = self.get_num_lines(self.messageArea) self.set_msg_height(numlines) self.messageArea.update() 添加一行（By WINTERSTAR）以后，发现已经生效了。参考这篇博客，我修改了字体和大小。但是这个窗口的位置还有点不太好。 同样修改位置的代码如下： self.set_pos(global_state.window_position) 由于我不想修改全局的代码，所以我在下面加了这一行覆盖上面的代码即可(不见得是覆盖，所以上面代码最好别删) self.set_pos(&quot;+10+0&quot;) +10表示离屏幕左边10像素点，+0表示离屏幕上边0像素点 这时候发现这个窗口太长了，要是能宽一点就好了。 然后发现下面有一行 self.boxRoot.minsize(100, 200) 我修改以后，就可以实现窗口的变化，但是并不智能，窗口的内容很少也显示的窗口很大 所以，我就单独把buttonbox以及它相关的库拿出来，然后把上述还原，只为释义窗口做了一个修改。 当然同样也有设置最大尺寸 self.boxRoot.maxsize(1400,600) # add By WINTERSTAR 那么这个easygui默认设置是灰色的，怎么修改颜色呢？使用rgb设置豆沙绿可以采用下面的代码 豆沙绿 self.messageArea = tk.Text( self.boxRoot, width=self.width_in_chars, # state=tk.DISABLED, # comment By WINTERSTAR padx=(global_state.default_hpad_in_chars) * self.calc_character_width(), relief=&quot;flat&quot;, foreground='black', # add By WINTERSTAR # background=self.boxRoot.config()[&quot;background&quot;][-1], # comment By WINTERSTAR background= &quot;#%02x%02x%02x&quot; % (128, 192, 200), # add By WINTERSTAR pady=global_state.default_hpad_in_chars * self.calc_character_width(), wrap=tk.WORD, ) 另外，如果想让界面处于可编辑的状态，那么出来要注释上面的DISABLED，还需要下面的DISABLED代码 def set_msg(self, msg): self.messageArea.config(state=tk.NORMAL) self.messageArea.delete(1.0, tk.END) self.messageArea.insert(tk.END, msg) # self.messageArea.config(state=tk.DISABLED) # comment By WINTERSTAR self.messageArea.config(font=self.boxFont) # add By WINTERSTAR # Adjust msg height self.messageArea.update() numlines = self.get_num_lines(self.messageArea) self.set_msg_height(numlines) self.messageArea.update() 那么配什么文字比较好呢？ 可以看看这个人使用的一些文字颜色搭配 ","link":"https://WinterStarHu.github.io/post/easygui-ku-zhong-can-shu-xiu-gai/"},{"title":"LeetCode题目进度","content":"开始了一个LeetCode题目的进度 上传到Github pycharm上传到github：https://blog.csdn.net/zha6476003/article/details/83052032 GitHub项目查看:https://github.com/WinterStarHu/LeetCode 遇到的一个问题：Permanently added the RSA host key for IP address '13.250.177.223' to t he list of known hosts. 解决方法：https://blog.csdn.net/yushuangping/article/details/84240863 使用LeetCode插件 Leetcode editor IDE 刷题工具 leetcode editor介绍 LeetCode editor本地调试 可以自定义模板 如上是我自定义的模板 得到的结果如上 enumerate 使用enumerate() 可以很好的提高运行速度 如下两数相加的例子中，可以大大提高运行速度，当然这少不了哈希表的配合 # leetcode submit region begin(Prohibit modification and deletion) class Solution(object): def twoSum(self, nums, target): hashmap = {} for ind, num in enumerate(nums): hashmap[num] = ind for i, num in enumerate(nums): j = hashmap.get(target - num) if j is not None and i != j: return [i, j] # leetcode submit region end(Prohibit modification and deletion) ","link":"https://WinterStarHu.github.io/post/leetcode-ti-mu-jin-du/"},{"title":"从一个错误的例子来学习递归","content":"在小甲鱼视频里，发现一个例子，然后根据递归用这个例子理解是最简单的。 def recursion() return recursion() 递归会调用自己 递归深度 递归需要有终止条件 ","link":"https://WinterStarHu.github.io/post/cong-yi-ge-cuo-wu-de-li-zi-lai-xue-xi-di-gui/"},{"title":"Python视频记录系列--小甲鱼96集视频","content":"B站地址：https://www.bilibili.com/video/av4050443 运算符 条件 循环 list的方法 tuple 孟德斯鸠：只有权力能够制约权力 字符串和元祖一样，都不能修改。 python官网可以下载python的chm文件，https://docs.python.org/3.7/download.html python中文学习大本营里有中文的参考 http://www.pythondoc.com/ 所以想想以前去找国内MATLAB书籍查看手册，是不好的做法，实际上更好的做法是通过MATLAB官网下载手册进行查看。这样更新更全。 字符串的方法及注释 格式化format和%的使用 实际上当我想去看帮助文档，发现很多都看不懂啊，那么只能慢慢理解了。 例如这个map函数 里面很多词都不认识，下面逐一了解了解吧，逐渐跳出自己的舒适圈，最近看编程陷入了死循环，难的看不懂，简单的不想看。 这个map函数的例子我在网上找了一个： &gt;&gt;&gt; numbers = ['1', '5', '10', '8'] &gt;&gt;&gt; map(int,numbers) &lt;map object at 0x0000020EE9890F60&gt; &gt;&gt;&gt; list(map(int,numbers)) [1, 5, 10, 8] &gt;&gt;&gt; 如上所示，可以把数组里字符变成数字。 [python迭代器(https://www.cnblogs.com/yudanqu/p/9084501.html) Python迭代器以及map和reduce函数目录 ","link":"https://WinterStarHu.github.io/post/python-shi-pin-ji-lu-xi-lie-xiao-jia-yu-96-ji-shi-pin/"},{"title":"百度云之放弃篇","content":"在尝试了一系列办法后，确认只有pandowload和百度云客户端，结合资源大圣的vip账户分享的办法最好。 尝试 尝试了油猴脚本的“网盘直链助手”等一系列配合软件 RPC，aria2 IDM Motrix 亿寻 等等。 都只有20Kb。。。 建议 pandowload和百度云客户端 资源大圣微信公众号的svip账户分享 ","link":"https://WinterStarHu.github.io/post/bai-du-yun-zhi-fang-qi-pian/"},{"title":"如何追求高效完整的人生--研究记录历程","content":"困于APP的干扰，各种记录无法实现完整而又持续的记录，用我们的方言说就是“三天心眼子”，形容一个人做一件事只有几天的热情，待热情消退就忘记了很多事。 APP列举，分类，筛选，整理 分类 关于这方面的APP太多了，我也使用过很多，但是无法持续。 上图是我所使用的效率APP 提醒类软件 ToDo 微软旗下的软件 高效ToDo 和ToDo是一个类型的 提醒事项 Apple的 时间轨迹软件 时间块 一天都做了啥，按照颜色区分 打卡类软件 小习惯 番茄钟和特定项时间记录 番茄ToDo coves 记账类软件 叨叨记账 不玩手机 iPhone自带的屏幕使用时间控制 Offscreen 人生类APP 余生 还有多长时间能活着，人生清单 教育类软件 阅读类软件 学习强国 ","link":"https://WinterStarHu.github.io/post/ru-he-zhui-qiu-gao-xiao-wan-zheng-de-ren-sheng-yan-jiu-ji-lu-li-cheng/"},{"title":"GitHub作为学习笔记资源搜索的渠道之一！","content":"GitHub是代码共享的平台之一，之前也说过可以通过码云Gitee导入GitHub的项目来实现快速下载。 今天突然想到，既然我可以将我的md笔记放在GitHub上，那么肯定也有别人是这样做的。之前只是在知乎里看见过很多的人分享GitHub上的项目，那么学习笔记肯定也很多。 比如这个最优化的笔记：https://github.com/anch3or/Optimization-Notes 这样我以后写博客既可以做到格式规整，又可以做到快速方便。 .ipynb文件打开方法 CSDN博客 如何打开.ipynb 文件 百度经验 如何打开 ipynb 文件 推荐使用这个nbviewer网站打开。看起来比较舒服 ","link":"https://WinterStarHu.github.io/post/github-zuo-wei-bi-ji-zi-yuan-sou-suo-de-qu-dao-zhi-yi/"},{"title":"Matlab使用技巧","content":"Matlab系列1：Matlab使用技巧 Matlab代码折叠功能 如何用代码折叠让 MATLAB 程序结构清晰易读呢 Matlab文件夹、文件、读取操作（汇总） Matlab分割文件路径，判断文件是否存在 matlab 分割字符串、提取文件路径及文件名 matlab判断文件或文件夹是否存在 filename ='E:\\test\\test.txt'; [pathstr,~,~]=fileparts(FileName); % pathstr 结果为目录 ; name 结果为文件名;suffix 结果为后缀 if ~exist(pathstr,'dir') mkdir(pathstr) end save(filename,'data'); 判断当前目录 s=what s.path 目录和路径拼接（类似python的join） 请教关于绝对路径转相对路径问题 f = fullfile(filepart1,...,filepartN) 根据指定的文件夹和文件名构建完整的文件设定。fullfile 在必要情况下插入依平台而定的文件分隔符，但不添加尾随的文件分隔符。在 Windows® 平台上，文件分隔符为反斜杠 ()。在其他平台上，文件分隔符可能为不同字符。 在 Windows 上，fullfile 将所有正斜杠 (/) 替换为反斜杠 ()。在 UNIX® 平台上，反斜杠 () 字符在文件名中是有效字符，不会被替换。 fullfile 不裁剪前导或尾随的分隔符。fullfile 折叠内部重复的文件分隔符，除非它们出现在完整文件设定的开头。fullfile 还将折叠由圆点符号指示的相对目录，除非它们出现在完整文件设定的末尾。由双圆点符号指示的相对目录不会折叠。 matlab选择进入当前文件的绝对路径 matlab 如何将.m文件所在的路径设置为当前活动目录（当前文件夹），以及保存到matlab搜索路径 % %设置本文件所在路径为当前工作空间路径 filep = mfilename('fullpath'); %filep包含了本m文件所在的路径已经以及文件名（不带.m后缀） [pathstr,namestr]=fileparts(filep);%pathstr才是本m文件所在的路径 cd(pathstr);%更改当前活动目录路径 matlab自动补全 matlab自动补全功能及代码对齐 matlab快捷键 matlab实用快捷键 ","link":"https://WinterStarHu.github.io/post/matlab-shi-yong-ji-qiao/"},{"title":"公式识别OCR","content":"这期整理一下公式OCR目前的软件，如下。 inftyReader InftyReader很好用，英文识别，中文不支持，整页pdf识别100%！！ mathpix API 天若OCR也是要调用mathpix的API，开启了软件收费模式，识别也要收费的模式。 旧版天若OCR是免费的可以使用 GitHub上已经有关于这个API的调用，img2latex，这个API有1000次的免费，肯定够用，但是要输入信用卡账户什么的，我并没有。 mathpix snipping tool mathpix提供的软件，每个月有50次免费的机会，多注册几个账户吧。。 海马扫描 国产软件，挺好用的，精确识别挺准的，精准识别0.05元/次。普通识别对于一行公式识别是可以的。暂时可以用。 赛酷OCR不支持使用，识别不出来，可能年代久远，竟然是调用mathtype的方式，而且也是20次收费。 公式996 公式996 和海马差不多。识别效果还没尝试。 MathOCR 首先安装jdk 然后配置JAVA环境变量 然后就可以使用mathOCR，效果不好。 公众号Pacco 这个公众号由原来的厦大电费变过来的，找了半天。有软件，也可以直接向公众号回复，回复打卡可以增加三次。还未测试。 其他 软件收费的流程 对于天若OCR： 吾爱破解--免费，GitHub开源--&gt;增加使用人数，扩展用户量 功能完善，人数增加 功能更强，吸引人数 调查市场行情，开启部分免费，部分收费--&gt;赚一部分人钱 收费之后，设置使用次数，再次收费--&gt;软件收费，功能细化收费 后期还可以去广告收费，逐渐扩大，直至免费，靠用户资源收费--企鹅用户量大也是其成功之一 --Pacco分支 再次开发： 对于竞争对手，研发相似功能产品，开启与之相比更多的免费，更低的价格，打价格战，用户体验战--&gt;拉拢用户 --收购： 某些公司发现某个软件做的好，价格合适就可以收购，如果开发成本低，就可以自己再次开发，这种方式在各种互联网软件很常见。类似于互补商品可以叫做互补应用。 尾注 [天若OCR](https://pan.baidu.com/s/1rePz6hicN5e9SHRFKXjHUg 提取码：2jem)和mathpix snip tool也可以在大话数据分析公众号进行下载 ","link":"https://WinterStarHu.github.io/post/gong-shi-shi-bie-ocr/"},{"title":"Markdown语法","content":"这里介绍一些常用的markdown语法，主要是不容易记住的。 latex公式 ∥x∥\\left \\|x\\right\\|∥x∥ ∣x∣\\left|x\\right|∣x∣ ≠\\neq​= ≥\\geq≥ ≤\\leq≤ ⟺\\Longleftrightarrow⟺ ∑xi\\sum_{x}^{i}∑xi​ max⁡1≤i≤n∣xi∣\\max_{1\\leq i\\leq n} \\left|x_i\\right|max1≤i≤n​∣xi​∣ 1p\\frac{1}{p}p1​ ×\\times× 参考资料： 最全 Markdown + Latex 编写技巧 ","link":"https://WinterStarHu.github.io/post/markdown-yu-fa/"},{"title":"搜索框及html特效字","content":"Gridea 搜索框 搜索框 修改header.ejs，使其在上右位置。 修改search.ejs，使其背景和主页一致 修改result_template.ejs，使其搜索结果竖排，文字加框以隔离不同结果 特效字 &lt;FONT style=&quot;FONT-SIZE: 40pt; FILTER: shadow (color=#af2dco); WIDTH: 100%; COLOR: #730404; LINE-HEIGHT: 100%; FONT-FAMILY: 华文行楷&quot; size=6&gt; 压雷科编生&lt;br&gt;缩达研程活&lt;br&gt;感成愉愉愉&lt;br&gt;知像快快快&lt;br&gt;！！！！！ &lt;/FONT&gt; 压雷科编生缩达研程活感成愉愉愉知像快快快！！！！！ ","link":"https://WinterStarHu.github.io/post/sou-suo-kuang-ji-html-te-xiao-zi/"},{"title":"看板娘 live2D的使用","content":"光说造轮子，用轮子也是挺不容易的，折腾了一下午，把小白该趟过的坑给说一下，本文使用资源 简书的教程 我的看板娘有些问题[1]，还有这个博客挺简单，博客也很好看啊 这个人使用的比较简单，加载也比较快，只是少了唱歌之类的功能。 加上这个人的代码和文件就可以补全按钮了 路径问题 将图片按照如上路径放置 代码位置 head代码 body代码 chorm浏览器开发者工具使用 elements 可以看代码写的位置对不对 network 可以看有些资源有没有加载出来，资源位置对不对，比如这个live2d.js 其他 顺便说一下 网易云音乐歌单 的方法 &lt;iframe src=&quot;https://music.163.com/outchain/player?type=0&amp;amp;id=2597425669&amp;amp;auto=0&amp;amp;height=430&quot; width=&quot;100%&quot; height=&quot;430&quot; frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot;&gt;&lt;/iframe&gt; 特效字体 chorm扩展 我的博客没有放大图片功能，推荐下面工具。哈哈，我就是事多吧，不会写html代码，只能这样委屈了。chorm大法！ Imagus：图片放大预览工具 imagus chorm商店 Failed to load resource: net::ERR_CONNECTION_REFUSED ↩︎ ","link":"https://WinterStarHu.github.io/post/kan-ban-niang-live2d-de-shi-yong/"},{"title":"代码着色html及右下角弹窗","content":"markdown下在线代码着色，不成功 使用谷歌扩展Code Block Beautifier成功！！ &lt;div class=&quot;dp-highlighter&quot;&gt;&lt;div class=&quot;bar&quot;&gt;&lt;/div&gt;&lt;ol start=&quot;1&quot; class=&quot;dp-j&quot;&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span&gt;function&amp;nbsp;[x,val,k]=grad(fun,gfun,x0)&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;%&amp;nbsp;功能:&amp;nbsp;用最速下降法求解无约束问题:&amp;nbsp;&amp;nbsp;min&amp;nbsp;f(x)&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;%输入:&amp;nbsp;&amp;nbsp;x0是初始点,&amp;nbsp;fun,&amp;nbsp;gfun分别是目标函数和梯度&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;%输出:&amp;nbsp;&amp;nbsp;x,&amp;nbsp;val分别是近似最优点和最优值,&amp;nbsp;&amp;nbsp;k是迭代次数.&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;maxk=&lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;&lt;span&gt;;&amp;nbsp;&amp;nbsp;&amp;nbsp;%最大迭代次数&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;rho=&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;&lt;span&gt;;sigma=&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;&lt;span&gt;;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;k=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span&gt;;&amp;nbsp;&amp;nbsp;epsilon=1e-&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span&gt;;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;&lt;span&gt;(k&amp;lt;maxk)&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g=feval(gfun,x0);&amp;nbsp;&amp;nbsp;%计算梯度&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;d=-g;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;%计算搜索方向&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;&lt;span&gt;(norm(d)&amp;lt;epsilon),&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;span&gt;;&amp;nbsp;end&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span&gt;;&amp;nbsp;mk=&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span&gt;;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;&lt;span&gt;(m&amp;lt;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;span&gt;)&amp;nbsp;&amp;nbsp;&amp;nbsp;%Armijo搜索&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;&lt;span&gt;(feval(fun,x0+rho^m*d)&amp;lt;feval(fun,x0)+sigma*rho^m*g'*d)&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mk=m;&amp;nbsp;&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;span&gt;;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;end&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m=m+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span&gt;;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;end&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0=x0+rho^mk*d;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;k=k+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span&gt;;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;end&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;&quot;&gt;&lt;span&gt;x=x0;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;val=feval(fun,x0);&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt; function&nbsp;[x,val,k]=grad(fun,gfun,x0)&nbsp;&nbsp;%&nbsp;功能:&nbsp;用最速下降法求解无约束问题:&nbsp;&nbsp;min&nbsp;f(x)&nbsp;&nbsp;%输入:&nbsp;&nbsp;x0是初始点,&nbsp;fun,&nbsp;gfun分别是目标函数和梯度&nbsp;&nbsp;%输出:&nbsp;&nbsp;x,&nbsp;val分别是近似最优点和最优值,&nbsp;&nbsp;k是迭代次数.&nbsp;&nbsp;maxk=5000;&nbsp;&nbsp;&nbsp;%最大迭代次数&nbsp;&nbsp;rho=0.5;sigma=0.4;&nbsp;&nbsp;k=0;&nbsp;&nbsp;epsilon=1e-5;&nbsp;&nbsp;while(k&lt;maxk)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g=feval(gfun,x0);&nbsp;&nbsp;%计算梯度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d=-g;&nbsp;&nbsp;&nbsp;&nbsp;%计算搜索方向&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(norm(d)&lt;epsilon),&nbsp;break;&nbsp;end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m=0;&nbsp;mk=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(m&lt;20)&nbsp;&nbsp;&nbsp;%Armijo搜索&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(feval(fun,x0+rho^m*d)&lt;feval(fun,x0)+sigma*rho^m*g'*d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk=m;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m=m+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x0=x0+rho^mk*d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k=k+1;&nbsp;&nbsp;end&nbsp;&nbsp;x=x0;&nbsp;&nbsp;val=feval(fun,x0);&nbsp;&nbsp; 谷歌扩展Code Block Beautifier的原理 A chrome extension for beautifying code blocks in any websites that contain pre elements. A chrome extension for highlighting codes of Medium Articles, but now, it can highlight codes in any websites that have HTML pre'element. 因此使用在线转换后的代码，也可以加上pre来实现高亮 function&nbsp;[x,val,k]=grad(fun,gfun,x0)&nbsp;&nbsp;%&nbsp;功能:&nbsp;用最速下降法求解无约束问题:&nbsp;&nbsp;min&nbsp;f(x)&nbsp;&nbsp;%输入:&nbsp;&nbsp;x0是初始点,&nbsp;fun,&nbsp;gfun分别是目标函数和梯度&nbsp;&nbsp;%输出:&nbsp;&nbsp;x,&nbsp;val分别是近似最优点和最优值,&nbsp;&nbsp;k是迭代次数.&nbsp;&nbsp;maxk=5000;&nbsp;&nbsp;&nbsp;%最大迭代次数&nbsp;&nbsp;rho=0.5;sigma=0.4;&nbsp;&nbsp;k=0;&nbsp;&nbsp;epsilon=1e-5;&nbsp;&nbsp;while(k&lt;maxk)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g=feval(gfun,x0);&nbsp;&nbsp;%计算梯度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d=-g;&nbsp;&nbsp;&nbsp;&nbsp;%计算搜索方向&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(norm(d)&lt;epsilon),&nbsp;break;&nbsp;end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m=0;&nbsp;mk=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(m&lt;20)&nbsp;&nbsp;&nbsp;%Armijo搜索&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(feval(fun,x0+rho^m*d)&lt;feval(fun,x0)+sigma*rho^m*g'*d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk=m;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m=m+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x0=x0+rho^mk*d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k=k+1;&nbsp;&nbsp;end&nbsp;&nbsp;x=x0;&nbsp;&nbsp;val=feval(fun,x0);&nbsp;&nbsp; 右下角弹窗实现网址 html更多特效 ","link":"https://WinterStarHu.github.io/post/dai-ma-zhao-se-html/"},{"title":"导航界面出现的问题","content":"最近从网上下载了一个导航界面，感觉挺好的。 遇到的问题 jquery引入的是 http: 但是你的链接是https 箭头处需要是https 这个弹出及搜索功能才能使用。 在QQ群里遇到的网友解释说是：HTTPS有安全策略，会拦截。😅 之前嵌入swf的问题 同样是https的问题！把http变成https就可以用了 &lt;embed type=&quot;application/x-shockwave-flash&quot; src=&quot;https://cdn.abowman.com/widgets/hamster/hamster.swf&quot; width=&quot;260&quot; height=&quot;210&quot; id=&quot;flashID&quot; name=&quot;flashID&quot; bgcolor=&quot;#FFFFFF&quot; quality=&quot;high&quot; flashvars=&quot;up_backgroundColor=FFFFFF&quot; wmode=&quot;opaque&quot; allowscriptaccess=&quot;always&quot;&gt; ","link":"https://WinterStarHu.github.io/post/dao-hang-jie-mian-chu-xian-de-wen-ti/"},{"title":"LoveStory","content":"inky可以编写交互性的网页。下面是我写的一个小东西，大家可以看看。 LoveStory #次要内容 Gridea可以把自己编写的网页放在static下，然后上传到GitHub，我们就可以通过链接访问这个外链。 使用netlify也可以托管自己的网页。 LoveStory ","link":"https://WinterStarHu.github.io/post/lovestory/"},{"title":"网页内添加音乐控件","content":"看见别人的博客里有音乐播放器，我也想加一个。本页内容比较乱，因为嵌入了html导致网页混乱，但是其中的方法可以参考。 主要内容 次要内容 主要内容 参考了这个博客，MarkDown插入音乐。 添加如下代码： &lt;div align=life&gt; &lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=400 height=140 src=&quot;https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 效果如下： 可以使用！！！ 这个接口的 id=34341360 是从这里获取的 找到复制链接 , 然后用浏览器打开. 后边的 id=34341360 就是我们要的 id 然后接口替换就可以了 次要内容 折叠插件 &lt;details&gt; &lt;summary&gt;点击时的区域标题&lt;/summary&gt; &lt;p&gt; - 测试 测试测试&lt;/p&gt; &lt;p&gt; 测试二 测试三 。。。。。 .&lt;/p&gt; &lt;/details&gt; 效果如下 点击时的区域标题 - 测试 测试测试 测试二 测试三 。。。。。 . 天气控件 &lt;div align=life&gt; &lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;100&quot; marginheight=&quot;0&quot; width=600 height=300 scrolling=&quot;no&quot; src=&quot;https://tianqi.qq.com/&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 只是限制了观看的区域，如果想从其他地方浏览还不知道怎么办。另外天气只有北京的也有点难办，看来这个可以搞一些动图什么的html可能还可以，若是天气就不好用了。 采用DIV区域控制，就可以使用了。下图是把百度图标隐藏的效果 &lt;div align=&quot;center&quot; style=&quot;margin:0 auto;&quot;&gt; &lt;div style=&quot;width:800px;height:600px;overflow:hidden;border:0px&quot;&gt; &lt;div style=&quot;width:500px;height:800px;margin:-153px 0px 0px -10px;&quot;&gt; &lt;iFrame src=&quot;http://www.baidu.com&quot; width=&quot;800&quot; height=&quot;600&quot; scrolling=&quot;no&quot;&gt; &lt;/iFrame&gt; &lt;/div&gt; &lt;/div&gt; 我使用百度搜索“天气预报”，得到搜索结果，然后选择区域，勉强显示出天气。 &lt;div style=&quot;width:800px;height:600px;overflow:hidden;border:0px&quot;&gt; &lt;div style=&quot;width:500px;height:800px;margin:-130px 0px 0px -10px;&quot;&gt; &lt;iFrame src=&quot;https://www.baidu.com/baidu?wd=天气&quot; width=&quot;300&quot; height=&quot;400&quot; scrolling=&quot;no&quot;&gt; &lt;/iFrame&gt; &lt;/div&gt; &lt;/div&gt; bing搜索weather的结果 网页上别人博客截下来的代码 &lt;div align=life&gt; &lt;iframe allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; width=&quot;180&quot; height=&quot;36&quot; scrolling=&quot;no&quot; src=&quot;//tianqi.2345.com/plugin/widget/index.htm?s=3&amp;amp;z=2&amp;amp;t=0&amp;amp;v=0&amp;amp;d=3&amp;amp;bd=0&amp;amp;k=&amp;amp;f=&amp;amp;ltf=009944&amp;amp;htf=cc0000&amp;amp;q=1&amp;amp;e=1&amp;amp;a=1&amp;amp;c=54511&amp;amp;w=180&amp;amp;h=36&amp;amp;align=center&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 另外，markdown里还有其他功能嵌入，如下： 文字颜色 插入视频 插入Gif 一行插入多张图片 &lt;table&gt; &lt;tr&gt; &lt;td &gt;&lt;center&gt; &lt;iframe allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; width=&quot;180&quot; height=&quot;36&quot; scrolling=&quot;no&quot; src=&quot;//tianqi.2345.com/plugin/widget/index.htm?s=3&amp;amp;z=2&amp;amp;t=0&amp;amp;v=0&amp;amp;d=3&amp;amp;bd=0&amp;amp;k=&amp;amp;f=&amp;amp;ltf=009944&amp;amp;htf=cc0000&amp;amp;q=1&amp;amp;e=1&amp;amp;a=1&amp;amp;c=54511&amp;amp;w=180&amp;amp;h=36&amp;amp;align=center&quot;&gt;&lt;/iframe&gt; &lt;/center&gt; &lt;center&gt; &lt;iframe frameborder=&quot;no&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=400 height=140 src=&quot;https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; &lt;/center&gt;&lt;/td &gt; &lt;/tr&gt; &lt;/table&gt; 闹钟 &lt;object type=&quot;application/x-shockwave-flash&quot; style=&quot;outline:none;&quot; data=&quot;https://cdn.abowman.com/widgets/pendulumclock/pendulumClockV2.swf?&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;param name=&quot;movie&quot; value=&quot;http://cdn.abowman.com/widgets/pendulumclock/pendulumClockV2.swf?&quot;&gt;&lt;/param&gt;&lt;param name=&quot;AllowScriptAccess&quot; value=&quot;always&quot;&gt;&lt;/param&gt;&lt;param name=&quot;wmode&quot; value=&quot;opaque&quot;&gt;&lt;/param&gt;&lt;param name=&quot;bgcolor&quot; value=&quot;&quot;/&gt;&lt;/object&gt; 鱼 &lt;object type=&quot;application/x-shockwave-flash&quot; style=&quot;outline:none;&quot; data=&quot;http://cdn.abowman.com/widgets/dog/dog.swf?3?&quot; width=&quot;300&quot; height=&quot;225&quot;&gt;&lt;param name=&quot;movie&quot; value=&quot;https://cdn.abowman.com/widgets/dog/dog.swf?3?&quot;&gt;&lt;/param&gt;&lt;param name=&quot;AllowScriptAccess&quot; value=&quot;always&quot;&gt;&lt;/param&gt;&lt;param name=&quot;wmode&quot; value=&quot;opaque&quot;&gt;&lt;/param&gt;&lt;param name=&quot;bgcolor&quot; value=&quot;FFFFFF&quot;/&gt;&lt;/object&gt; 老鼠 &lt;embed type=&quot;application/x-shockwave-flash&quot; src=&quot;https://cdn.abowman.com/widgets/hamster/hamster.swf&quot; width=&quot;260&quot; height=&quot;210&quot; id=&quot;flashID&quot; name=&quot;flashID&quot; bgcolor=&quot;#FFFFFF&quot; quality=&quot;high&quot; flashvars=&quot;up_backgroundColor=FFFFFF&quot; wmode=&quot;opaque&quot; allowscriptaccess=&quot;always&quot;&gt; ","link":"https://WinterStarHu.github.io/post/wang-ye-nei-tian-jia-yin-le-kong-jian/"},{"title":"记一次使用淘宝的经历","content":"淘宝用的好，搜索也很棒！ 问题背景 😀⚽️曾经我给一个同学推荐《Make Your Own Neural Network》的书籍，并把代码和英文书发给了他，但是，我印象中不知怎么地，我把这本书翻译成了《自己动手写神经网络》，然后我也没有这本书的中文版，等他找到这本书中文版，才发现不是Make Your Own Neural Network的中文版。 解决方法 😀⚽️然后我通过淘宝搜索《自己动手写神经网络》，我自己也清楚这个名字只有这一本书。不过万能的淘宝给我推荐了我想要的书。 淘宝推荐很棒啊！ 其他 淘宝搜索电子元器件也是很好的一种办法，而且如果运气好的话，你可以向卖家免费要到元器件资料或者开发板资料等等。 搜索插件 既然提到了搜索，那么就介绍一个搜索插件。Greasy Fork是一个提供用户脚本的网站，在chorm上安装油猴tampermonkey扩展后即可使用这个网站上的脚本。 AC-baidu: 重定向优化百度搜狗谷歌搜索_去广告_favicon_双列功能如下： 繞過百度、搜狗、谷歌、好搜搜索結果中的自己的跳轉鏈接，直接訪問原始網頁 - 反正都能看懂 新增拦截百度百家号的无用推广数据 - 支持其他站点 去除百度的多余广告 添加 Favicon 显示 页面 CSS 添加计数 开关选择以上功能 效果如下图： ","link":"https://WinterStarHu.github.io/post/ji-yi-ci-shi-yong-tao-bao-de-jing-li/"},{"title":"使用Git工具上传文件到Github及误删恢复","content":"本文介绍了使用Git工具上传文件到GitHub的仓库。建议小伙伴们先备份待上传目录的内容再操作。某些操作会导致文件丢失。本博客也介绍了误删恢复的方法 步骤如下： 1、新建库 进入Github首页新建仓库 填写相应信息create 复制下地址备用 2、接下来输入如下代码（关键步骤），把 github 上面的仓库克隆到本地 git clone https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git 替换成你之前复制的地址） 3、 这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你 github 上面的项目名，如图我多出了个 Test 文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下， 4、 接着继续输入命令 cd Test，进入 Test 文件夹 5、接下来依次输入以下代码即可完成其他剩余操作： git add . （注：别忘记后面的.，此操作是把 Test 文件夹下面的文件都添加进来） git commit -m &quot;提交信息&quot; （注：“提交信息” 里面换成你需要，如 “first commit”） git push -u origin master （注：此操作目的是把本地仓库 push 到 github 上面，此步骤需要你输入帐号和密码） 误删除恢复教程 ​ 由于我之前不是按照上述比较优的方案进行的，是采用git init方案，在本地生成然后上传，然后导致同步的时候，本地文件丢失了，这也让我对git commit ‘message’有了一定的理解。感谢博主的恢复方案。 1、 git reflog 由于我只有一个commit：c9ae14a HEAD@{1}: commit (initial): first commit 2、 用 reset (Suppose the old commit was HEAD@{1} in the ref log) git reset --hard HEAD@{1} ##GitHub文件更新 文件更新 解决！ ","link":"https://WinterStarHu.github.io/post/wang-ye-shang-gong-shi-xian-shi-bu-quan-de-jie-jue-ban-fa-ji-wu-shan-hui-fu/"},{"title":"网页上公式显示不正常的解决办法","content":"已通过更换Gridea主题为Note解决了公式显示的问题， 由于网站采用Gridea的模板存在一些问题，所以公式不能正常的显示，显示的形式是Latex代码。本博客会介绍一种安装Chorm扩展的的方法来解决这个问题。 采用的办法 ​ 如上图所示，公式不能很好的显示出来，只能显示出Latex代码。为了能直接解决这个问题，需要修改Gridea软件的配置，比较麻烦[1]。然后我想到通过chorm扩展来实现，在这个人的博客里搜索到这样一款插件Math Anywhere。安装好以后就可以有如下效果： 如上图所示，和正常的公式显示还是有些区别的，不过能够大致看懂，暂时只能这样解决了。 其他办法 ​ 有人提到这样一种嵌入网页图片的办法，但是我又看见有人说这种办法可能存在引擎失效的风险，因此还是采用第一种办法来解决这个问题。 ​ 直接采用截图的方式来处理，这样会造成格式的混乱，而且不利于以后的管理。 本地端观看的方法 ​ 如果为了更好的观看，可以在我的GIthub上下载下来使用Typora观看。 https://zhuanlan.zhihu.com/p/36302775 ↩︎ ","link":"https://WinterStarHu.github.io/post/wang-ye-shang-gong-shi-xian-shi-bu-quan-de-jie-jue-ban-fa/"},{"title":"1.最速下降法","content":"鉴于自己非数学专业，数学知识薄弱，所以只写了一部分，没办法。我是先看最速下降法然后再写其他内容的，所以弃更的部分在中间。如果想接着看下去，请看书。 最优化系列会对常见的优化算法进行学习。 第一个优化算法是最速下降法，它是最优化中求解无约束优化问题的一种方法，本博客会介绍问题的简介，步骤，程序实现，程序使用，详细内容见参考文献。 说明 最优化的概念 向量范数 向量范数的定义 常用的范数: 向量范数的性质 矩阵范数 矩阵范数的性质 矩阵范数和向量范数的联系 常见的诱导范数 常见的非诱导范数 向量序列和矩阵序列的收敛性 函数的可微性 定义1.1 函数的泰勒展开 最速下降法 问题简介 问题步骤 算法3.1 最速下降法[^2] 程序实现 程序 3.1(最速下降法) 程序使用 例3.1 利用程序3.1求解无约束优化问题 * 参考文献[^6] 说明 ​ 本文中公式编号是从1开始编号，和参考文献列举的书中公式编号无关。但是定理、算法、程序、例子等，便于使用脚注，且为了查阅方便，故采用书中的编号，且脚注上会标明是哪本书的编号。 不理解的用这个色彩表示 最优化的概念 ​ 最速下降法其中的一步会使用到线搜法，因此首先介绍线搜法。 ​ 通俗地说，所谓最优化问题，就是求一个多元函数在某个给定集合上的极值. 几乎所有类型的最优化问题都可以用下面的数学模型来描述: minf(x),s.t.x∈Kmin f(x),s.t. x\\in K minf(x),s.t.x∈K ​ 这里，$ 𝐾 $ 是某个给定的集合(称为可行集或可行域)，$ 𝑓(𝑥) $ 是定义在集合$ 𝐾 $ 上的实值函数. 此外，在公式(1) 中，$ 𝑥 $ 通常称为决策变量, $ s.t. $ 是 subject to (受限于) 的缩写. 人们通常按照可行集的性质对最优化问题(1) 进行一个大致的分类: 线性规划和非线性规划. — 可行集是有限维空间中的一个子集; 组合优化或网络规划. — 可行集中的元素是有限的; 动态规划. — 可行集是一个依赖时间的决策序列; 最优控制. — 可行集是无穷维空间中的一个连续子集. 非线性规划 minf(x)min f(x) minf(x) s.t. hi(x)=0,i=1,⋯ ,lgi(x)≥0,i=1,⋯ ,m\\begin{aligned} &amp;\\begin{array}{ll} {\\text { s.t. }} &amp; {h_{i}(x)=0, i=1, \\cdots, l} \\\\ {} &amp; {g_{i}(x) \\geq 0, \\quad i=1, \\cdots, m} \\end{array} \\end{aligned} ​ s.t. ​hi​(x)=0,i=1,⋯,lgi​(x)≥0,i=1,⋯,m​​ ​ 其中，𝑓(𝑥),h𝑖(𝑥)(𝑖=1,⋅⋅⋅,𝑙)𝑓(𝑥), ℎ_𝑖(𝑥) (𝑖 = 1, · · · , 𝑙)f(x),hi​(x)(i=1,⋅⋅⋅,l) 及𝑔𝑖(𝑥)(𝑖=1,⋅⋅⋅,𝑚)𝑔_𝑖(𝑥) (𝑖 = 1, · · · ,𝑚)gi​(x)(i=1,⋅⋅⋅,m) 都是定义在R𝑛R_𝑛Rn​上连续可微的多元实值函数,且至少有一个是非线性的.记𝐸=𝑖:h𝑖(𝑥)=0,𝐼=𝑖:𝑔𝑖(𝑥)≥0.𝐸={𝑖:ℎ_𝑖(𝑥)=0},𝐼={𝑖:𝑔_𝑖(𝑥)≥0}.E=i:hi​(x)=0,I=i:gi​(x)≥0.若指标集𝐸∪𝐼=∅𝐸∪𝐼=∅E∪I=∅称之为无约束优化问题，否则称为约束优化问题.特别地,把𝐸≠∅𝐸 \\neq ∅E​=∅且𝐼=∅𝐼=∅I=∅ 的优化问题称为等式约束优化问题;而把𝐼≠∅𝐼 \\neq ∅I​=∅且𝐸=∅𝐸 = ∅E=∅的优化问题称为不等式约束优化问题.𝑓(𝑥)𝑓(𝑥)f(x)称为目标函数,h𝑖(𝑥),𝑔𝑗(𝑥)(𝑖=1,⋅⋅⋅,𝑙;𝑗=1,⋅⋅⋅,𝑚)ℎ_𝑖(𝑥),𝑔_𝑗(𝑥)(𝑖=1,···,𝑙;𝑗=1,···,𝑚)hi​(x),gj​(x)(i=1,⋅⋅⋅,l;j=1,⋅⋅⋅,m)称为约束函数.此外，通常把目标函数为二次函数而约束函数都是线性函数的优化问题称为二次规划；而目标函数和约束函数都是线性函数的优化问题称为线性规划. 向量范数 在算法的收敛性分析中，需要用到向量和矩阵范数的概念及其有关理论. 设Rn\\mathbb{R}^nRn 表示实𝑛维向量空间，R𝑛×𝑛\\mathbb{R}^{𝑛×𝑛}Rn×n 表示实𝑛阶矩阵全体所组成的线性空间.在这两个空间中，我们分别定义向量和矩阵的范数. 向量范数的定义 ∥x∥p=(∑i=1n∣x∣p)1p\\left \\|x\\right\\|_p=({\\sum_{i=1}^n{\\left|x\\right|^p}})^{\\frac{1}{p}} ∥x∥p​=(i=1∑n​∣x∣p)p1​ 常用的范数: 1范数 元素绝对值之和 ∥x∥1=∑i=1n∣x∣\\left \\|x\\right\\|_1={\\sum_{i=1}^n{\\left|x\\right|}} ∥x∥1​=i=1∑n​∣x∣ 2范数 元素的平方和开根号 ∥x∥2=∑i=1n∣x∣2\\left \\|x\\right\\|_2=\\sqrt{\\sum_{i=1}^n{\\left|x\\right|}^2} ∥x∥2​=i=1∑n​∣x∣2​ 无穷范数 元素绝对值的最大值 ∥x∥∞=max⁡1≤i≤n∣xi∣\\left \\|x\\right\\|_\\infty=\\max_{1\\leq i\\leq n} \\left|x_i\\right| ∥x∥∞​=1≤i≤nmax​∣xi​∣ 向量范数的性质 非负性 ∥x∥≥0\\left \\|x\\right\\| \\geq 0∥x∥≥0 ∥x∥=0⟺x=0\\left \\|x\\right\\|=0 \\Longleftrightarrow x=0∥x∥=0⟺x=0 齐次性∥λx∥=∣λ∣∥x∥,λ∈R\\left \\|\\lambda x\\right\\|=\\left|\\lambda\\right|\\left \\|x\\right\\|,\\lambda\\in\\R∥λx∥=∣λ∣∥x∥,λ∈R 三角不等式∥x+y∥≤∥x∥+∥y∥\\left\\|x+y\\right\\|\\leq\\left \\|x\\right\\|+\\left \\|y\\right\\|∥x+y∥≤∥x∥+∥y∥ 矩阵范数 矩阵范数的性质 矩阵范数的定义和性质与向量范数一致。除此之外，还有以下两条性质 柯西不等式 ∥AB∥≤∥A∥∙∥B∥,A,B∈Rn×n\\left \\|AB\\right\\|\\leq\\left \\|A\\right\\| \\bullet \\left \\|B\\right\\|,A,B\\in \\mathbb{R}^{n \\times n}∥AB∥≤∥A∥∙∥B∥,A,B∈Rn×n 矩阵范数和向量范数的联系 相容性∥Ax∥≤∥A∥μ∥x∥,x∈Rn,A∈Rn×n\\left \\|Ax\\right\\|\\leq\\left \\|A\\right\\|_\\mu\\left \\|x\\right\\|,x\\in\\mathbb{R}^n,A\\in \\mathbb{R}^{n\\times n}∥Ax∥≤∥A∥μ​∥x∥,x∈Rn,A∈Rn×n 矩阵范数和向量范数是相容的，怎么理解 算子范数:，若存在x≠0x\\neq 0x​=0，且 ∥A∥μ=max⁡x≠0∥Ax∥∥x∥=max⁡∥x∥=1∥Ax∥,A∈Rn×n\\|A\\|_{\\mu}=\\max _{x \\neq 0} \\frac{\\|A x\\|}{\\|x\\|}=\\max _{\\|x\\|=1}\\|A x\\|, \\quad A \\in \\mathbb{R}^{n \\times n} ∥A∥μ​=x​=0max​∥x∥∥Ax∥​=∥x∥=1max​∥Ax∥,A∈Rn×n 则称矩阵范数∥∙∥μ\\|\\bull\\|_{\\mu}∥∙∥μ​是由向量范数∥∙∥\\|\\bull\\|∥∙∥诱导出来的算子范数，简称算子范数，有时也称为从属于向量范数∥∙∥\\|\\bull\\|∥∙∥的矩阵范数. 此时向量范数和算子范数通常采用相同的符号∥∙∥\\|\\bull\\|∥∙∥。 常见的诱导范数 从属于向量范数∥x∥∞\\|x\\|_\\infty∥x∥∞​, ∥x∥1\\|x\\|_1∥x∥1​, ∥x∥2\\|x\\|_2∥x∥2​ 的矩阵范数分行和范数、列和范数和谱范数。 ∥A∥∞=max⁡1≤i≤n∑j=1n∣aij∣\\|A\\|_{\\infty}=\\max _{1 \\leq i \\leq n} \\sum_{j=1}^{n}\\left|a_{i j}\\right| ∥A∥∞​=1≤i≤nmax​j=1∑n​∣aij​∣ ∥A∥1=max⁡1≤j≤n∑i=1n∣aij∣\\|A\\|_{1}=\\max _{1 \\leq j \\leq n} \\sum_{i=1}^{n}\\left|a_{i j}\\right| ∥A∥1​=1≤j≤nmax​i=1∑n​∣aij​∣ ∥A∥2=max⁡{λ∣λ∈λ(ATA)}\\|A\\|_{2}=\\max \\left\\{\\sqrt{\\lambda} | \\lambda \\in \\lambda\\left(A^{T} A\\right)\\right\\} ∥A∥2​=max{λ​∣λ∈λ(ATA)} 行和范数，即所有矩阵行向量绝对值之和的最大值 。 列和范数，即所有矩阵列向量绝对值之和的最大值。 谱范数，即ATAA^TAATA矩阵的最大特征值的开平方(开平方即为开根号的意思)。 常见的非诱导范数 非诱导范数常见的为 F - 范数，即 Frobenius 范数以及核范数 。 Frobenius 范数，即矩阵元素绝对值的平方和再开平方。 ∥A∥F=(∑i=1n∑j=1naij2)1/2=tr⁡(ATA)\\|A\\|_{F}=\\left(\\sum_{i=1}^{n} \\sum_{j=1}^{n} a_{i j}^{2}\\right)^{1 / 2}=\\sqrt{\\operatorname{tr}\\left(A^{T} A\\right)} ∥A∥F​=(i=1∑n​j=1∑n​aij2​)1/2=tr(ATA)​ 核范数[1] Nuclear Norm，即矩阵奇异值的和[1:1]。 ∥A∥∗=∑i=1nλi,λi为矩阵A的奇异值\\|A\\|_{*}=\\sum_{i=1}^{n} \\lambda_{i},\\lambda_i为矩阵A的奇异值 ∥A∥∗​=i=1∑n​λi​,λi​为矩阵A的奇异值 向量序列和矩阵序列的收敛性 向量序列和矩阵序列的收敛性[2] 收敛性暂时不做考虑，这一节仅列举出来供参考。 函数的可微性 本节主要介绍后文经常需要用到 𝑛𝑛n元函数的一阶和二阶导数以及泰 勒展开式. 定义1.1 设有𝑛𝑛n 元实函数𝑓(𝑥),𝑓(𝑥),f(x), 其中自变量𝑥=(𝑥1,⋅⋅⋅,𝑥𝑛)𝑇∈R𝑛𝑥 = (𝑥_1, · · · , 𝑥_𝑛)^𝑇 ∈R_𝑛x=(x1​,⋅⋅⋅,xn​)T∈Rn​称向量 ∇f(x)=(∂f(x)∂x1,∂f(x)∂x2,⋯ ,∂f(x)∂xn)T\\nabla f(x)=\\left(\\frac{\\partial f(x)}{\\partial x_{1}}, \\frac{\\partial f(x)}{\\partial x_{2}}, \\cdots, \\frac{\\partial f(x)}{\\partial x_{n}}\\right)^{T} ∇f(x)=(∂x1​∂f(x)​,∂x2​∂f(x)​,⋯,∂xn​∂f(x)​)T 为f(x)f(x)f(x)在xxx处的一阶导数或梯度。 称矩阵 为f(x)f(x)f(x)在xxx处的二阶导数或Hesse矩阵。若梯度∇𝑓(𝑥)∇𝑓(𝑥)∇f(x) 的每个分量函数在𝑥𝑥x 都连续, 则称𝑓𝑓f 在𝑥𝑥x 一阶连续可微；若Hesse 阵∇2𝑓(𝑥)∇^2𝑓(𝑥)∇2f(x) 的各个分量函数都连续，则称𝑓𝑓f 在𝑥𝑥x 二阶连续可微. 若𝑓𝑓f在开集𝐷𝐷D的每一点都连续可微，则称𝑓𝑓f在 𝐷𝐷D上一阶连续可微；若 𝑓𝑓f在开集𝐷𝐷D的每一点都都二阶连续可微，则称 𝑓𝑓f在 𝐷𝐷D上二阶连续可微. 函数的泰勒展开 弃更了，准备先看看再更新这个内容吧，我太难了。 最速下降法 ​ 多维无约束优化问题是指在没有任何限制条件下寻求目标函数的极小点，其表达多维无约束优化问题是指在没有任何限制条件下寻求目标函数的极小点，其表达式为 min⁡x∈Rnf(x)\\min _{x \\in \\mathbb{R}^{n}} f(x) x∈Rnmin​f(x) 问题简介 ​ 最速下降法由法国数学家 Cauchy于1947年首先提出。该算法在每次迭代中，沿最速下降方向（负梯度方向）进行搜索，每步沿负梯度方向取最优步长，因此这种方法也称为最优梯度法。 ​ 最速下降法方法简单，只以一阶梯度的信息确定下一步的搜索方向，收敛速度慢；越是接近极值点，收敛越慢；它是其他许多无约束、有约束最优化方法的基础。该方法一般用于最优化开始的几步搜索。[3] 问题步骤 ​ 最速下降法是用负梯度方向 dk=−∇f(xk)d_{k}=-\\nabla f\\left(x_{k}\\right) dk​=−∇f(xk​) 作为搜索方向的，因此也称为梯度法。 ​ 解释如下： ​ 设f(x)f(x)f(x) 在xkx_kxk​附近连续可微，dkd_kdk​为搜索方向向量，gk=∇f(xk)g_{k}=\\nabla f\\left(x_{k}\\right)gk​=∇f(xk​). 由泰勒展开式得： f(xk+αdk)=f(xk)+αgkTdk+o(α),α&gt;0f\\left(x_{k}+\\alpha d_{k}\\right)=f\\left(x_{k}\\right)+\\alpha g_{k}^{T} d_{k}+o(\\alpha), \\quad \\alpha&gt;0 f(xk​+αdk​)=f(xk​)+αgkT​dk​+o(α),α&gt;0 那么目标函数f(x)f(x)f(x)在xkx_kxk​处沿方向dkd_kdk​ 下降的变化率为 lim⁡α→0f(xk+αdk)−f(xk)α=lim⁡α→0∣αgkTdk+o(α)α=gkTdk=∥gk∥∥dk∥cos⁡θˉk\\begin{aligned} \\lim _{\\alpha \\rightarrow 0} \\frac{f\\left(x_{k}+\\alpha d_{k}\\right)-f\\left(x_{k}\\right)}{\\alpha} &amp;=\\lim _{\\alpha \\rightarrow 0} \\frac{| \\alpha g_{k}^{T} d_{k}+o(\\alpha)}{\\alpha} \\\\ &amp;=g_{k}^{T} d_{k}=\\left\\|g_{k}\\right\\|\\left\\|d_{k}\\right\\| \\cos \\bar{\\theta}_{k} \\end{aligned} α→0lim​αf(xk​+αdk​)−f(xk​)​​=α→0lim​α∣αgkT​dk​+o(α)​=gkT​dk​=∥gk​∥∥dk​∥cosθˉk​​ 其中θˉk\\bar\\theta_kθˉk​是gkg_kgk​和dkd_kdk​的夹角。显然，对于不同方向dkd_kdk​，函数变化率取决于它与gkg_kgk​的夹角的余弦值。要想使变化率最小，只有cos(θˉk)=−1cos(\\bar\\theta_k)=-1cos(θˉk​)=−1，即θˉk=π\\bar\\theta_k=\\piθˉk​=π时才能达到，亦即dkd_kdk​应该取(2)中的负梯度方向，这也是将负梯度方向叫做最速下降方向的由来。下面给出最速下降法的具体计算步骤。 算法3.1 最速下降法[2:1] ​ 步0 选取初始点x0∈Rnx_{0} \\in \\mathbb{R}^{n}x0​∈Rn，容许误差0≤ε≪10 \\leq \\varepsilon \\ll 10≤ε≪1.令k:=1. ​ 步1 计算gk=Δf(xk)g_k=\\Delta f(x_k)gk​=Δf(xk​).若∥gk∥≤ε\\left\\|g_{k}\\right\\| \\leq \\varepsilon∥gk​∥≤ε，停算，输出xkx_kxk​作为近似最优解。 ​ 步2 取方向dk=−gkd_k=-g_kdk​=−gk​ ​ 步3 由线搜索技术确定步长因子αk\\alpha_kαk​. ​ 步4 令xk+1:=xk+αkdkx_k+1:=x_k+\\alpha_k d_kxk​+1:=xk​+αk​dk​，k=k+1k=k+1k=k+1，转步1 ​ 说明 步3中步长因子αkα_kαk​的确定即可使用精确线搜索方法，也可以使用非精确线搜索方法，在理论上都能保证其全局收敛性。 ​ 精确线搜索方法保证全局收敛性的证明如下： ​ 若采用精确线搜索方法，即 f(xk+αkdk)=min⁡α≥0f(xk+αdk)f\\left(x_{k}+\\alpha_{k} d_{k}\\right)=\\min _{\\alpha \\geq 0} f\\left(x_{k}+\\alpha d_{k}\\right) f(xk​+αk​dk​)=α≥0min​f(xk​+αdk​) 那么αk\\alpha_kαk​应满足 ϕ′(α)=ddαf(xk+αdk)∣α=αk=∇f(xk+αkdk)Tdk=0\\phi^{\\prime}(\\alpha)=\\left.\\frac{\\mathrm{d}}{\\mathrm{d} \\alpha} f\\left(x_{k}+\\alpha d_{k}\\right)\\right|_{\\alpha=\\alpha_{k}}=\\nabla f\\left(x_{k}+\\alpha_{k} d_{k}\\right)^{T} d_{k}=0 ϕ′(α)=dαd​f(xk​+αdk​)∣∣∣∣​α=αk​​=∇f(xk​+αk​dk​)Tdk​=0 由(2)式有 ∇f(xk+1)T∇f(xk)=0\\nabla f\\left(x_{k+1}\\right)^{T} \\nabla f\\left(x_{k}\\right)=0 ∇f(xk+1​)T∇f(xk​)=0 即新点xk+1x_{k+1}xk+1​处的梯度与旧点xkx_kxk​处的梯度是正交的，也就是说迭代点列所走的路线是锯齿型的，故其收敛速度是很缓慢的(至多线性收敛速度)。 ​ 由dk=−gkd_k=-g_kdk​=−gk​及下式 cos⁡θk=−gkTdk∥gk∥∥dk∥=−gkT(−gk)∥gk∥∥−gk∥=1,⇒θk=0\\cos \\theta_{k}=\\frac{-g_{k}^{T} d_{k}}{\\left\\|g_{k}\\right\\|\\left\\|d_{k}\\right\\|}=\\frac{-g_{k}^{T}\\left(-g_{k}\\right)}{\\left\\|g_{k}\\right\\|\\left\\|-g_{k}\\right\\|}=1, \\Rightarrow \\theta_{k}=0 cosθk​=∥gk​∥∥dk​∥−gkT​dk​​=∥gk​∥∥−gk​∥−gkT​(−gk​)​=1,⇒θk​=0 故条件0≤θk≤π2−μ,μ∈(0,π2)0 \\leq \\theta_{k} \\leq \\frac{\\pi}{2}-\\mu, \\quad \\mu \\in\\left(0, \\frac{\\pi}{2}\\right)0≤θk​≤2π​−μ,μ∈(0,2π​) 。从而直接应用定理2.2[2:2]和定理2.3[2:3]即得最速下降法的全局收敛性定理。 ​ 最速下降法全局收敛性定理3.1： ​ 设目标函数f(x)f(x)f(x)连续可微且其梯度函数Δf(x)\\Delta f(x)Δf(x)是Lipschitz连续的，{xk}\\{x_k\\}{xk​}由最速下降法产生，其中步长因子αk\\alpha_kαk​由精确线搜索或由Wolfe 准则, 或由Armijo 准则产生。则有 lim⁡k→∞∥∇f(xk)∥=0\\lim _{k \\rightarrow \\infty}\\left\\|\\nabla f\\left(x_{k}\\right)\\right\\|=0 k→∞lim​∥∇f(xk​)∥=0 程序实现 ​ 下面给出基于Armijo 非精确线搜索的最速下降法Matlab 程序. 程序 3.1(最速下降法) function [x,val,k]=grad(fun,gfun,x0) % 功能: 用最速下降法求解无约束问题: min f(x) %输入: x0是初始点, fun, gfun分别是目标函数和梯度 %输出: x, val分别是近似最优点和最优值, k是迭代次数. maxk=5000; %最大迭代次数 rho=0.5;sigma=0.4; k=0; epsilon=1e-5; while(k&lt;maxk) g=feval(gfun,x0); %计算梯度 d=-g; %计算搜索方向 if(norm(d)&lt;epsilon), break; end m=0; mk=0; while(m&lt;20) %Armijo搜索 if(feval(fun,x0+rho^m*d)&lt;feval(fun,x0)+sigma*rho^m*g'*d) mk=m; break; end m=m+1; end x0=x0+rho^mk*d; k=k+1; end x=x0; val=feval(fun,x0); 程序使用 例3.1 利用程序3.1求解无约束优化问题 min⁡x∈R2f(x)=100(x12−x2)2+(x1−1)2\\min _{x \\in \\mathbb{R}^{2}} f(x)=100\\left(x_{1}^{2}-x_{2}\\right)^{2}+\\left(x_{1}-1\\right)^{2} x∈R2min​f(x)=100(x12​−x2​)2+(x1​−1)2 该问题有精确解x∗=(1,1)T,f(x∗)=0x^*=(1,1)^T,f(x^*)=0x∗=(1,1)T,f(x∗)=0。 ​ 分别建立grad.m(1.3 程序实现)，fun.m，gfun.m脚本函数。 %计算目标函数 function f=fun(x) f=100*(x(1)^2-x(2))^2+(x(1)-1)^2; % 计算目标函数的梯度 function g=gfun(x) g=[400*x(1)*(x(1)^2-x(2))+2*(x(1)-1), -200*(x(1)^2-x(2))]'; ​ main函数如下，用于调用上述函数。 %main函数 x0_set=[0,0;2,1;1,-1;-1,-1;-1.2,1;10,-10]; for i_x0=1:size(x0_set,1) x0=x0_set(i_x0,:)'; [x,val,k]=grad('fun','gfun',x0); %x0是初值，x是最小值，f(x)是最小函数值,nitr是迭代次数 fprintf('x0:(%.2f,%.2f) x:(%.2f,%.2f) y:%f nitr:%d\\n',x0(1),x0(2),x(1),x(2),val,k); end ​ 选取初值x0x0x0为不同的值，有不同的结果。运行结果如下： 参考文献[4] [矩阵范数及其求导](https://www.cnblogs.com/go-go/p/9674984.html) ↩︎ ↩︎ 马昌凤. 最优化方法及其Matlab程序设计[M]. 科学出版社, 2010. ↩︎ ↩︎ ↩︎ ↩︎ 李娅. MATLAB R2015b最优化计算[M]. 清华大学出版社, 2017. ↩︎ 参考文献格式：中华人民共和国国家标准GBT7714-2015 ↩︎ ","link":"https://WinterStarHu.github.io/post/1zui-su-xia-jiang-fa/"},{"title":"Hello Makrdown","content":"本网站由Github Pages提供静态网页服务，Gridea提供写作服务和markdown代码转网页服务 以下是markdown语法： 👏 欢迎使用 **Gridea** ！ ✍️ **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... &lt;!-- more --&gt; [Github](https://github.com/getgridea/gridea) [Gridea 主页](https://gridea.dev/) [示例网站](http://fehey.com/) ## 特性👇 📝 你可以使用最酷的 **Markdown** 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 **Windows**，**MacOS** 或 **Linux** 设备上使用此客户端 🌎 你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统 🇬🇧 你可以使用**中文简体**或**英语** 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ 工具 markdown表格生成 - 在线工具 markdown实现折叠操作 表格折叠 图片折叠 指定表格列宽 markdown添加空格 图床 ","link":"https://WinterStarHu.github.io/post/hello-gridea/"}]}